In ''[[database]]s'', ''[[transaction processing]]'', and related [[Distributed computing|distributed applications]], '''Commitment ordering''' (or '''Commit ordering'''; CO) is a ''[[serializability]]'' technique, both centralized and distributed. It allows [[Optimistic concurrency control|optimistic]] (non-blocking) implementations. CO is also the name of the resulting transaction [[Schedule (computer science)|schedule]] (history) property. In a CO compliant schedule the chronological order of commitment events of transactions is compatible with the [[Serializability#Testing conflict serializability|precedence]] order of the respective transactions. CO is a broad special case of [[serializability#View and conflict serializability|conflict serializability]], and effective means ([[Reliability|reliable]], high-performance, [[Distributed computing|distributed]], and [[Scalability|scalable]]) to achieve ''[[global serializability]]'' across any collection of database systems that possibly use different [[concurrency control]] mechanisms (CO also makes each system serializability compliant, if not already). Achieving this has been characterized as [[open problem]] until the public disclosure of CO in 1991 by Yoav Raz from [[Digital Equipment Corporation]] (DEC; see [[Global serializability]]). Each not-CO-compliant database system is augmented with a CO component (the Commitment Order Coordinator - COCO) which orders the commitment events for CO compliance, with neither data-access nor any other transaction operation interference. As such CO provides an [[atomic commitment]] protocol based, low overhead, general solution for global serializability (and distributed serializability), instrumental for [[global concurrency control]] (and [[distributed concurrency control]]) of multi database systems and other [[transactional object]]s, possibly highly distributed. CO is the most general property (a [[necessary condition]]) that guarantees global serializability, if the database systems involved do not share concurrency control information beyond atomic commitment protocol (unmodified) messages (the database systems are ''autonomous''). It generalizes the popular ''[[Two-phase locking#Strong strict two-phase locking|Strong strict two-phase locking]]'' (SS2PL) property, which in conjunction with the ''[[Two-phase commit protocol]]'' (2PC) is the [[de facto standard]] to achieve global serializability across (SS2PL based) database systems. As a result CO compliant database systems (with any, different concurrency control types) can transparently join such SS2PL based solutions for global serializability.

In addition, locking based global deadlocks are resolved automatically in a CO based multi database environment (including the special case of a completely SS2PL based environment).

Furthermore, '''Strict commitment ordering''' (SCO), the intersection of [[Schedule (computer science)#Strict|Strictness]] and CO, provides better performance (shorter average transaction completion time and resulting better transaction [[throughput]]) than SS2PL whenever read-write [[Serializability#View and conflict serializability|conflicts]] are present (identical blocking behavior for write-read and write-write conflicts; comparable locking overhead). The advantage of SCO is especially significant during lock contention.

Two major generalizing variants of CO exist, '''Extended CO''' (ECO) and '''Multi-version CO''' (MVCO), which as well provide global serializability. Both use additional information for relaxing constraints and achieving better concurrency and performance. CO and its variants interoperate transparently, guaranteeing global serializability also together in a mixed, heterogeneous environment with different variants.

==Overview==

CO (Raz 1992) has been referred to also as ''commit ordering'', and ''commit order serializability'' and ''strong recoverability''. The latter is a misleading name since CO is incomparable with ''[[serializability#Correctness - recoverability|recoverability]]'', and the term "strong" implies a special case. This means that a schedule with a strong recoverability property does not necessarily have the CO property, and vice versa.

In a [[federated database system]] or any other more loosely defined multidatabase system, which are typically distributed in a communication network, transactions span multiple (and possibly [[Distributed database|distributed]]) databases. Enforcing [[global serializability]] in such system is problematic. Even if every local schedule of a single database is serializable, the global schedule of a whole system is not necessarily serializable. The massive communication exchanges of conflict information needed between databases to reach [[Serializability#View and conflict serializability|conflict serializability]] would lead to unacceptable performance, primarily due to computer and communication [[latency (engineering)|latency]]. The problem of achieving global serializability effectively had been characterized as [[open problem|open]] until the end of 1991 (see ''[[Global serializability]]'').

Enforcing CO is an effective way to enforce conflict serializability globally in a distributed system, since enforcing CO locally in each database (or other transactional object) also enforces it globally. Each database may use any, possibly different, type of [[concurrency control]] mechanism. With a local mechanism that already provides conflict serializability, enforcing CO locally does not cause any additional aborts, since enforcing CO locally does not affect the data access scheduling strategy of the mechanism (this scheduling determines the serializability related aborts; such a mechanism typically does not consider the commitment events or their order). The CO solution requires no communication overhead, since it uses (unmodified) ''[[atomic commitment]]'' protocol messages only, already needed by each distributed transaction to reach [[atomicity]]. An atomic commitment protocol plays a central role in the distributed CO algorithm, which enforces CO globally, by breaking global cycles (cycles that span two or more database) in the global conflict graph.
CO, its special cases, and its generalizations are compatible, and achieve global serializability while transparently being utilized together in a single heterogeneous distributed environment comprising objects with possibly different concurrency control mechanisms. As such, ''Commitment ordering'', including its special cases, and together with its generalizations (see CO variants below), provides a general, high performance, fully distributed solution (no central processing component or central data structure are needed) for guaranteeing ''[[global serializability]]'' in heterogeneous environments of multidatabase systems and other multiple [[transactional object]]s (objects with states accessed and modified only by transactions; e.g., in the framework of [[transactional processes]]). The CO solution scales up with network size and the number of databases without any negative impact on performance (assuming the statistics of a single distributed transaction, e.g., the average number of databases involved with a single transaction, are unchanged).

==The commitment ordering solution for global serializability==
===General characterization of CO===

''Commitment ordering'' (CO) is a special case of [[serializability#View and conflict serializability|conflict serializability]]. CO can be enforced with non-blocking mechanisms (each transaction can complete its task without having its data-access blocked, which allows [[optimistic concurrency control]]; however, commitment could be blocked). In a CO schedule the commitment events' ([[partial order|partial]]) precedence order of the transactions corresponds to the precedence (partial) order of the respective transactions in the ([[directed graph|directed]]) conflict graph ([[Serializability#Testing conflict serializability|precedence graph]], serializability graph), as induced by their conflicting access operations (usually read and write (insert/modify/delete) operations; CO also applies to higher level operations, where they are conflicting if [[noncommutative]], as well as to conflicts between operations upon multi-version data). 

*'''Definition - Commitment ordering'''

:Let <math>T_{1}, T_{2}</math> be two ''committed'' transactions in a schedule, such that <math>T_{2}</math> is ''in a conflict'' with <math>T_{1}</math> (<math>T_{1}</math> ''precedes'' <math>T_{2}</math>). The schedule has the '''Commitment ordering''' (CO) property, if for every two such transactions <math>T_{1}</math> commits before <math>T_{2}</math> commits.


The commitment decision events are generated by either a local commitment mechanism, or an [[atomic commitment]] protocol, if different processes need to reach consensus on whether to commit or abort. The protocol may be distributed or centralized. Transactions may be committed concurrently, if the commit [[partial order]] allows (if they do not have conflicting operations). If different conflicting operations induce different partial orders of same transactions, then the conflict graph has [[cyclic graph|cycles]], and the schedule will violate serializability when all the transactions on a cycle are committed. In this case no partial order for commitment events can be found. Thus, cycles in the conflict graph need to be broken by aborting transactions. However, any conflict serializable schedule can be made CO without aborting any transaction, by properly delaying commit events to comply with the transactions' precedence partial order.

CO enforcement by itself is not sufficient as a concurrency control mechanism, since CO lacks the [[Serializability#Correctness - recoverability|recoverability]] property, which should be supported as well.

===The distributed CO algorithm===

A fully distributed ''Global commitment ordering'' enforcement algorithm exists, that uses local CO of each participating database, and needs only (unmodified) [[atomic commitment]] protocol messages with no further communication. The distributed algorithm is the combination of local (to each database) CO algorithm processes, and an atomic commitment protocol ([[Two-phase commit protocol#Common architecture|which can be fully distributed]]).
Atomic commitment protocol is essential to enforce [[atomicity]] of each distributed transaction (to decide whether to commit or abort it; this procedure is always carried out for distributed transactions, independently of concurrency control and CO). A common example of an atomic commitment protocol is the ''[[two phase commit]]'' protocol, which is resilient to many types of system failure. In a reliable environment, or when processes usually fail together (e.g., in the same [[integrated circuit]]), a simpler protocol for atomic commitment (still with a voting mechanism, like all such protocols) may be used.

====Enforcing global CO====

In each database system a local CO algorithm determines the needed commitment order for that database. By the characterization of CO above, this order depends on the local precedence order of transactions, which results from the local data access scheduling mechanisms. Accordingly votes-to-commit in the atomic commitment protocol are scheduled for each (unaborted) distributed transaction. If a precedence relation (conflict) exists between two transactions, then the second will not be voted on before the first is completed (either committed or aborted), to prevent possible commit order violation by the atomic commitment protocol. Such can happen since the commit order by the protocol is not necessarily the same as the voting order. If no precedence relation exists, both can be voted on concurrently. This voting strategy ensures that also the atomic commitment protocol maintains commitment order, and it is a necessary condition for guaranteeing Global CO (and the local CO of a database; without it both Global CO and Local CO (a property meaning that each database is CO compliant) may be violated). 

However, since database systems schedule their transactions independently, it is possible that the transactions' precedence orders in two databases or more are not compatible (no global [[partial order]] exists that can embed the respective local partial orders together). With CO precedence orders are also the commitment orders. When participating databases in a same distributed transaction do not have compatible local precedence orders for that transaction (without "knowing" it; typically no coordination between database systems exists on conflicts, since the needed communication is massive and unacceptably degrades performance) it means that the transaction resides on a global cycle (involving two or more databases) in the global conflict graph. In this case the atomic commitment protocol will fail to collect all the votes needed to commit that transaction: At least one database will delay its vote for that transaction indefinitely, to comply with its own commitment (precedence) order, since it will be waiting to the completion of another, preceding transaction on that global cycle, delayed indefinitely by another database with a different order. This means a '''''voting-[[deadlock]]''''' situation involving the databases on that cycle. 
As a result the protocol will eventually abort some deadlocked transaction on this global cycle, since each such transaction is missing at least one participant's vote. Selection of the specific transaction on the cycle to be aborted depends on the atomic commitment protocol's abort policies (a [[timeout (telecommunication)|timeout]] mechanism is common, but it may result in more than one needed abort per cycle; both preventing unnecessary aborts and abort time shortening can be achieved by a dedicated abort mechanism for CO). Such abort will break the global cycle involving that distributed transaction. Both deadlocked transactions and possibly other in conflict with the deadlocked (and thus blocked) will be free to be voted on. It is worthwhile noting that each database involved with the voting-deadlock continues to vote regularly on transactions that are not in conflict with its deadlocked transaction, typically almost all the outstanding transactions. Thus, in case of incompatible local (partial) commitment orders, no action is needed since the atomic commitment protocol resolves it automatically by aborting a transaction that is a cause of incompatibility. This means that the above voting policy is also a sufficient condition for guaranteeing Global CO. 

The following is concluded:

*'''The Global CO Enforcing Theorem'''

:Let <math>T_{1}, T_{2}</math> be undecided (neither committed nor aborted) transactions in a database system that enforces CO for local transactions, such that <math>T_{2}</math> is ''global'' and ''in conflict'' with <math>T_{1}</math> (<math>T_{1}</math> ''precedes'' <math>T_{2}</math>). Then, having <math>T_{1}</math> ended (either committed or aborted) before <math>T_{2}</math> is voted on to be committed, in each such database system in a multidatabase environment, is a [[necessary and sufficient condition]] for guaranteeing Global CO (the condition guarantees Global CO, which may be violated without it).

:'''Comment:''' The Local CO property of a global schedule means that each database is CO compliant. From the necessity discussion part above it directly follows that the theorem is true also when replacing "Global CO" with "Local CO" when global transactions are present. Together it means that Global CO is guaranteed [[if and only if]] Local CO is guaranteed (which is untrue for Global conflict serializability and Local conflict serializability: Global implies Local, but not the opposite).


Global CO implies Global serializability.

The Global CO algorithm comprises enforcing (local) CO in each participating database system by ordering commits of local transactions and enforcing the voting condition in the theorem above (for global transactions).

====More on global cycles and voting-deadlocks====

The above global cycle elimination process by a '''voting deadlock''' can be explained in detail by the following observation: 

First it is assumed, for simplicity, that every transaction reaches the ready-to-commit state and is voted on by at least one database (this implies that no blocking by locks occurs).
Define a ''"wait for vote to commit" graph'' as a directed graph with transactions as nodes, and a directed edge from any first transaction to a second transaction if the first transaction blocks the vote to commit of the second transaction (opposite to conventional edge direction in a [[wait-for graph]]). Such blocking happens only if the second transaction is in a conflict with the first transaction (see above). Thus this "wait for vote to commit" graph is identical to the global conflict graph (has exactly the same definition - see [[serializability#Testing conflict serializability|in Serializability]]). A cycle in the "wait for vote to commit" graph means a deadlock in voting. Hence there is a deadlock in voting if and only if there is a cycle in the conflict graph. Local cycles (confined to a single database) are eliminated by the local serializability mechanisms. Consequently only global cycles are left, which are then eliminated by the atomic commitment protocol when it aborts deadlocked transactions with missing (blocked) respective votes. 

Secondly, also local commits are dealt with: Note that when enforcing CO also waiting for a regular local commit of a local transaction can block local commits and votes of other transactions upon conflicts, and the situation for global transactions does not change also without the simplifying assumption above: The final result is the same also with local commitment for local transactions, without voting in atomic commitment for them. 

Finally, blocking by a lock (which has been excluded so far) needs to be considered: A lock blocks a conflicting operation and prevents a conflict from being materialized. If the lock is released only after transaction end, it may block indirectly either a vote or a local commit of another transaction (which now cannot get to ready state), with the same effect as of a direct blocking of a vote or a local commit. In this case a cycle is generated in the conflict graph only if such a blocking by a lock is also represented by an edge. With such added edges representing events of blocking-by-a-lock, the conflict graph is becoming an ''augmented conflict graph''. 

*'''Definition - Augmented conflict graph'''

:An '''augmented conflict graph''' is a [[serializability#Testing conflict serializability|conflict graph]] with added edges: In addition to the original edges a directed edge exists from transaction <math>T_{1}</math> to transaction <math>T_{2}</math> if two conditions are met:
:# <math>T_{2}</math> is blocked by a data-access lock applied by <math>T_{1}</math> (the blocking prevents the conflict of <math>T_{2}</math> with <math>T_{1}</math> from being materialized and have an edge in the regular conflict graph), and
::2. This blocking will not stop before <math>T_{1}</math> ends (commits or aborts; true for any locking-based CO)

:The graph can also be defined as the [[Union (set theory)|union]] of the (regular) ''conflict graph'' with the (reversed edge, regular) ''wait-for graph''

:'''Comments:''' 
# Here, unlike the regular conflict graph, which has edges only for materialized conflicts, all conflicts, both materialized and non-materialized, are represented by edges.
# Note that all the new edges are all the (reversed to the conventional) edges of the ''[[wait-for graph]]''. The ''wait-for graph'' can be defined also as the graph of non-materialized conflicts. By the common conventions edge direction in a ''conflict graph'' defines time order between conflicting operations which is opposite to the time order defined by an edge in a ''wait-for graph''.
# Note that such global graph contains (has embedded) all the (reversed edge) regular local ''wait-for'' graphs, and also may include locking based global cycles (which cannot exist in the local graphs). For example, if all the databases on a global cycle are SS2PL based, then all the related vote blocking situations are caused by locks (this is the classical, and probably the only global deadlock situation dealt with in the database research literature). This is a global deadlock case where each related database creates a portion of the cycle, but the complete cycle does not reside in any local wait-for graph. 

In the presence of CO the ''augmented conflict graph'' is in fact a (reversed edge) ''local-commit and voting wait-for graph'': An edge exists from a first transaction, either local or global, to a second, if the second is waiting for the first to end in order to be either voted on (if global), or locally committed (if local). All ''global cycles'' (across two or more databases) in this graph generate voting-deadlocks. The graph's global cycles provide complete characterization for voting deadlocks and may include any combination of materialized and non-materialized conflicts. Only cycles of (only) materialized conflicts are also cycles of the regular conflict graph and affect serializability. One or more (lock related) non-materialized conflicts on a cycle prevent it from being a cycle in the regular conflict graph, and make it a locking related deadlock. All the global cycles (voting-deadlocks) need to be broken (resolved) to both maintain global serializability and resolve global deadlocks involving data access locking, and indeed they are all broken by the atomic commitment protocol due to missing votes upon a voting deadlock.

'''Comment:''' This observation also explains the correctness of ''[[Commitment ordering#Extended CO (ECO)|Extended CO (ECO)]]'' below: Global transactions' voting order must follow the conflict graph order with vote blocking when order relation (graph path) exists between two global transactions. Local transactions are not voted on, and their (local) commits are not blocked upon conflicts. This results in same voting-deadlock situations and resulting global cycle elimination process for ECO.

The ''voting-deadlock'' situation can be summarized as follows:

*'''The CO Voting-Deadlock Theorem'''

:Let a multidatabase environment comprise CO compliant (which eliminates ''local cycles'') database systems that enforce, each, ''Global CO'' (using the condition in the theorem above). Then a ''voting-deadlock'' occurs [[if and only if]] a ''global cycle'' (spans two or more databases) exists in the ''Global augmented conflict graph'' (also blocking by a data-access lock is represented by an edge). If the cycle does not break by any abort, then all the ''global transactions'' on it are involved with the respective voting-deadlock, and eventually each has its vote blocked (either directly, or indirectly by a data-access lock); if a local transaction resides on the cycle, eventually it has its (local) commit blocked.

:'''Comment:''' A rare situation of a voting deadlock (by missing blocked votes) can happen, with no voting for any transaction on the related cycle by any of the database systems involved with these transactions. This can occur when all the databases involved are locking based. The highest probability instance of such rare event involves two transactions on two simultaneous opposite cycles. Such global cycles (deadlocks) overlap with local cycles which are resolved locally, and thus typically resolved by local mechanisms without involving atomic commitment. Formally it is also a global cycle, but practically it is local (portions of local cycles generate a global one; to see this, split each global transaction (node) to local subtransactions (its portions confined each to a single database); a directed edge exists between transactions if an edge exists between any respective local subtransactions; a cycle is local if all its edges originate from a cycle among subtransactions of the same database, and global if not; global and local can overlap: a same cycle among transactions can result from several different cycles among subtransactions, and be both local and global).


Also the following locking based special case is concluded:

*'''The CO Locking-based Global-Deadlock Theorem'''

:In a CO compliant multidatabase system a locking-based global-deadlock, involving at least one data-access lock (non-materialized conflict), and two or more database systems, is a reflection of a global cycle in the ''Global augmented conflict graph'', which results in a voting-deadlock. Such cycle is not a cycle in the (regular) ''Global conflict graph'' (which reflects only materialized conflicts, and thus such cycle does not affect ''[[serializability]]'').

:'''Comments:''' 
# Any blocking (edge) in the cycle that is not by a data-access lock is a direct blocking of either voting or local commit. All voting-deadlocks are resolved (almost all by ''Atomic commitment''; see comment above), including this locking-based type.
# Locking-based global-deadlocks can be generated also in a completely-SS2PL based distributed environment (special case of CO based), where all the vote blocking (and voting-deadlocks) are caused by data-access locks. Many research articles have dealt for years with resolving such global deadlocks, but none (except the CO articles) is known (as of 2009) to notice that ''atomic commitment'' automatically resolves them.

Voting-deadlocks are the key for the operation of distributed CO. See [[Commitment ordering#Examples|Examples]] below.

Global cycle elimination (here voting-deadlock resolution by ''atomic commitment'') and resulting aborted transactions' re-executions are time consuming, regardless of concurrency control used. If databases schedule transactions independently, global cycles are unavoidable (any transaction or operation scheduling coordination results in autonomy violation, and typically also in substantial performance penalty). However, in many cases their likelihood can be made very low by implementing database and transaction design guidelines that reduce the number of conflicts involving a global transaction. This, primarily by properly handling ''[[hot spot]]s'', and avoiding conflicts by [[Serializability#View and conflict serializability|using commutativity]] when possible (e.g., when extensively using counters, as in finances, and especially multi-transaction ''accumulation counters'', which are typically hot spots).

Atomic commitment protocols are intended and designed to achieve [[atomicity]] without considering database concurrency control. They abort upon detecting or [[Heuristic algorithm|heuristically]] finding (e.g., by [[timeout (telecommunication)|timeout]]; sometimes mistakenly, unnecessarily) missing votes, and typically unaware of global cycles. These protocols can be specially enhanced for CO (including CO's variants below) both to prevent unnecessary aborts, and to accelerate aborts used for breaking global cycles in the global augmented conflict graph (for better performance by earlier release upon transaction-end of computing resources and typically locked data). For example, existing locking based global deadlock detection methods, other than timeout, can be generalized to consider also local commit and vote direct blocking, besides data access blocking.

===Enforcing CO locally===

''Commitment ordering'' can be enforced locally (in a single database) by a dedicated CO algorithm, or by any algorithm/protocol that provides any special case of CO. An important such protocol, being utilized extensively in database systems, which generates a CO schedule, is the ''strong [[Schedule (computer science)#Strict|strict]] [[two phase locking]]'' protocol (SS2PL: "release transaction's locks only after the transaction has been either committed or aborted"; see below). SS2PL is a [[proper subset]] of the intersection of [[2PL]] and [[Schedule (computer science)#Strict|strictness]].

====A generic local CO algorithm====

A generic CO algorithm is an algorithm independent of implementation details, that enforces exactly the CO property. It does not block data access (nonblocking), and consists of aborting transactions (only if needed) before committing a transaction. It aborts a (uniquely determined at any given time) minimal set of other undecided (neither committed, nor aborted) transactions that run locally and can cause serializability violation in the future (can later generate cycles of committed transactions in the conflict graph). This set consists of all undecided transactions with directed edges in the conflict graph to the transaction to be committed. The size of this set cannot increase when that transaction is waiting to be committed (in ready state: processing has ended), and typically decreases in time as its transactions are being decided. Thus, unless [[Real-time computing|real-time]] constraints exist to complete set members, it is preferred to wait with committing this transaction and let this set decrease in size. If another serializability mechanism exists locally (which eliminates cycles in the local conflict graph), or if no cycle involving that transaction exists, the set will be empty eventually, and no abort of set member is needed. Otherwise the set will stabilize with transactions on local cycles, and aborting set members will have to occur to break the cycles. Since in the case of CO conflicts generate blocking on commit, local cycles in the ''augments conflict graph'' (see above) indicate local commit-deadlocks, and deadlock resolution techniques as in [[Serializability#Common mechanism - SS2PL|SS2PL]] can be used (e.g., timeout and wait-for graph; the ''augmented conflict graph'' local cycles reflect deadlocks by blocking caused by both materialized and non-materialized conflicts; a single local cycle elimination mechanism both guarantees local serializability and handles locking based (with at least one lock) local deadlocks). Practically an additional concurrency control mechanism is always utilized even solely to enforce [[serializability#Correctness - recoverability|recoverability]]. The generic CO algorithm does not affect local data access scheduling strategy, when it runs alongside of any other local concurrency control mechanism. It affects only the commit order, and for this reason it does not need to abort more transactions than those needed to be aborted for serializability violation prevention by any combined local concurrency control mechanism. The net effect of CO may be, at most, a delay of commit events (or voting in a distributed environment), to comply with the needed commit order (but not more delay than its special cases, for example, SS2PL, and on the average significantly less).

====Implementation considerations - The Commitment Order Coordinator (COCO)====

A database system in a multidatabase environment is assumed. From a [[software architecture]] point of view a CO component that implements the generic CO algorithm locally, the ''Commitment Order Coordinator'' (COCO), can be designed in a straightforward way as a [[mediator pattern|mediator]] between a (single) database system and an atomic commitment protocol component (Raz 1991b). However, the COCO is typically an integral part of the database system. The COCO's functions are to vote to commit on ready global transactions (processing has ended) according to the local commitment order, to vote to abort on transactions for which the database system has initiated an abort (the database system can initiate abort for any transaction, for many reasons), and to pass the atomic commitment decision to the database system. For local transactions (when can be identified) no voting is needed. For determining the commitment order the COCO maintains an updated representation of the local conflict graph of the undecided (neither committed nor aborted) transactions as a data structure (e.g., utilizing mechanisms similar to [[lock (computer science)|locking]], but with no data-access blocking). The COCO component has an [[interface (computer science)|interface]] with its database system to receive conflict, "ready" (processing has ended; readiness to vote on a global transaction or commit a local one), and abort notifications from the database system. It also interfaces with the atomic commitment protocol to vote and to receive the atomic commitment protocol's decision on each global transaction. The decisions are delivered from the COCO to the database system through their interface, as well as local transactions' commit notifications, at a proper commit order. The COCO, including its interfaces, can be enhanced, if it implements another variant of CO (see below), or plays a role in the database's concurrency control mechanism beyond voting in atomic commitment.

The COCO also guarantees CO locally in a single, isolated database system with no interface with an atomic commitment protocol.

===CO is a necessary condition for global serializability across autonomous database systems===

If the databases that participate in distributed transactions (i.e., transactions that span more than a single database) do not use any shared concurrency control information and use unmodified atomic commitment protocol messages (for reaching atomicity), then maintaining (local) ''commitment ordering'' is a [[necessary condition]] for guaranteeing global serializability (Raz 1992); obviously it is also a [[sufficient condition]]. This is a mathematical fact derived from the definitions of ''[[serializability]]'' and a ''[[Database transaction|transaction]]''. It means that if not complying with CO, then global serializability cannot be guaranteed under this condition (the condition of no concurrency control information sharing between databases beyond atomic commit protocol messages). Atomic commitment is a minimal requirement for a distributed transaction since it is always needed, which is implied by the definition of transaction. Thus, defining ''database autonomy'' and ''independence'' as complying with this requirement is probably the broadest such definition in the context of database concurrency control. 

*'''Definition - ''' (Concurrency control based) '''Autonomous Database System'''
:A database system is '''Autonomous''', if it does not share with any other entity any concurrency control information beyond unmodified [[atomic commitment]] protocol messages.


Using this definition the following is concluded:

*'''The CO and Global serializability Theorem'''

:CO compliance of every ''autonomous'' database system (or transactional object) in a multidatabase environment is a ''necessary condition'' for guaranteeing Global serializability (without CO Global serializability may be violated). 
:CO compliance of every database system is a ''sufficient condition'' for guaranteeing Global serializability.


'''Comment:''' The definition of autonomy above implies that transactions are scheduled in a way that local transactions (confined to a single database) cannot be identified as such by an autonomous database system. This is realistic for some transactional objects, but less realistic for general purpose database systems. If autonomy is augmented with the ability to identify local transactions, then compliance with a more general property, ''Extended commitment ordering'' (ECO, see below), is the necessary condition.

===Summary===

The ''Commitment ordering'' (CO) solution for ''[[Global serializability]]'' can be summarized as follows:

If each ''database'' (or any other ''transactional object'') in a multidatabase environment complies with CO, i.e., arranges its local transactions' commitments and its votes on (global, distributed) transactions to the ''[[atomic commitment]]'' protocol according to the local (to the database) [[partial order]] induced by the local [[serializability#testing conflict serializability|conflict graph]] (serializability graph) for the respective transactions, then ''Global CO'' and ''Global serializability'' are guaranteed. A database's CO compliance can be achieved effectively with any local [[Serializability#View serializability and conflict serializability|conflict serializability]] based concurrency control mechanism, with neither affecting any transaction's execution process or scheduling, nor aborting it. Also the database's autonomy is not violated. The only low overhead incurred is detecting conflicts (e.g., as with locking, but with no data-access blocking; if not already detected for other purposes), and ordering votes and local transactions' commits according to the conflicts.

[[Image:CO-ScheduleClasses.jpg|thumb|350px| '''Schedule classes containment:''' An arrow from class A to class B indicates that class A strictly contains B; a lack of a directed path between classes means that the classes are incomparable.

A property is '''inherently-blocking''', if it can be enforced only by blocking transaction<U+2019>s data access operations until certain events occur in other transactions.]]

In case of incompatible partial orders of two or more databases (no global partial order can embed the respective local partial orders together), a global cycle (spans two databases or more) in the global conflict graph is generated. This, together with CO, results in a cycle of blocked votes, and a ''voting-[[deadlock]]'' occurs for the databases on that cycle (however, allowed concurrent votings in each database, typically almost all the outstanding votings, continue to execute). In this case the atomic commitment protocol fails to collect all the votes needed for the blocked transactions on that global cycle, and consequently the protocol aborts some transaction with a missing vote. This breaks the global cycle, the voting-deadlock is resolved, and the related blocked votings are free to be executed. Breaking the global cycle in the global conflict graph ensures that both Global CO and [[Global serializability]] are maintained. Thus, in case of incompatible local (partial) commitment orders no action is needed since the atomic commitment protocol resolves it automatically by aborting a transaction that is a cause for the incompatibility. Furthermore, also global deadlocks due to locking (global cycles in the ''augmented conflict graph'' with at least one data access blocking) result in voting deadlocks and are resolved automatically by the same mechanism.

''Local CO'' is a necessary condition for guaranteeing ''Global serializability,'' if the databases involved do not share any concurrency control information beyond (unmodified) atomic commitment protocol messages, i.e., if the databases are ''autonomous'' in the context of concurrency control. This means that every global serializability solution for autonomous databases must comply with CO. Otherwise global serializability may be violated.

The CO solution [[Scalability|scales up]] with network size and the number of databases without performance penalty when it utilizes [[Two-phase commit protocol#Common architecture|common distributed atomic commitment architecture]].

See [[Commitment ordering#Examples|Examples]] below.

==Distributed serializability and CO==

The previous section explains how CO guarantees [[global serializability]] in a multidatabase and multi transactional-object environment. This section explores the conditions under which CO provides [[serializability]] in a general [[Distributed computing|distributed]] transactional environment (e.g., a [[distributed database]] system), achieving a major goal of [[distributed concurrency control]]. 

===Distributed CO===

A distinguishing characteristic of the CO solution to distributed serializability from other techniques is the fact that it requires no conflict information distributed (or equivalent, e.g., locks, [[Timestamp-based concurrency control|timestamps]], tickets), which makes it uniquely effective. It utilizes (unmodified) [[atomic commitment]] protocol messages (which are already used) instead.

A common way to achieve distributed serializability in a [[Distributed system|(distributed) system]] is by a [[distributed lock manager]] (DLM). DLMs, which communicate lock (non-materialized conflict) information in a distributed environment, typically suffer from computer and communication [[Latency (engineering)|latency]], which reduces the performance of the system. CO allows to achieve distributed serializability under very general conditions, without a distributed lock manager, exhibiting the benefits already explored for multidatabase environments; in particular: [[Reliability engineering|reliability]], high performance, [[scalability]], possibilities of using ''[[optimistic concurrency control]]'' when desired, and no conflict information related communications over the network (which have incurred overhead and delays).

All ''distributed transactional systems'' rely on some [[atomic commitment]] protocol to coordinate [[atomicity (database systems)|atomicity]] (whether to commit or abort) among processes in a [[distributed transaction]]. Also, typically ''recoverable data'' (i.e., data under transactions' control, e.g., database data; not to be confused with the ''[[Serializability#Correctness - recoverability|recoverability]]'' property of a schedule) are directly accessed by a single ''transactional data manager'' component (also referred to as a ''resource manager'') that handles local sub-transactions (the distributed transaction's portion in a single location, e.g., network node), even if these data are accessed indirectly by other entities in the distributed system during a transaction (i.e., indirect access requires a direct access through a local sub-transaction). Thus recoverable data in a distributed transactional system are typically partitioned among transactional data managers. In such system these transactional data managers typically comprise the participants in the system's atomic commitment protocol. If each participant complies with CO (e.g., by using SS2PL or a COCO or a combination; see above), then the entire distributed system provides CO (by the theorems above; each participant can be considered a separate transactional object), and thus serializability. Furthermore: When CO is utilized together with an atomic commitment protocol also ''distributed deadlocks'' caused by data-access locking (span two or more data managers) are resolved automatically. Thus the following corollary is concluded:

*'''The CO based distributed serializability theorem'''

:Let a ''distributed transactional system'' (e.g., a [[distributed database]] system) comprise ''transactional data managers'' (also called ''resource managers'') that manage all the system's ''recoverable data''. The data managers meet three conditions:
# '''Data partition:''' Recoverable data are partitioned among the data managers, i.e., each recoverable datum (data item) is controlled by a single data manager (even copies of same data under different data managers are physically distinct, ''replicated''). 
# '''Participants in atomic commitment protocol:''' These data managers are the participants in the system's atomic commitment protocol for coordinating distributed transactions' atomicity. 
# '''CO compliance:''' Each such data manager is CO compliant (or some CO variant compliant; see below). 
:Then 
# The entire distributed system guarantees (distributed CO and) ''serializability'', and 
# Data-access based ''distributed deadlocks'' (deadlocks involving two or more data managers with at least one non-materialized conflict) are resolved automatically.


This theorem also means that when SS2PL (or any other CO variant) is used locally in each transactional data manager, and each data manager has exclusive control of its data, no distributed lock manager (which is often utilized to enforce distributed SS2PL) is needed for distributed serializability. It is relevant to a wide range of distributed transactional applications, which can be easily designed to meet these conditions.

===Optimistic distributed CO===

For implementing distributed [[Optimistic concurrency control|optimistic]] CO (OCO) the [[Commitment ordering#A generic local CO algorithm|generic local CO algorithm]] above is utilized in all the atomic comitment protocol participants in the system with no data access blocking and thus with no local deadlocks. The previous theorem has the following corollary:

*'''The optimistic distributed CO theorem'''

:If [[Optimistic concurrency control|optimistic]] distributed CO is utilized, then:
::# No local deadlocks occur, and
::# Global (voting) deadlocks are resolved automatically.

:Thus, no deadlock handling is needed.

===Examples===

====Distributed SS2PL====

A distributed database system that utilizes [[Two-phase locking#Strong strict two-phase locking|SS2PL]] resides on two remote nodes, A and B. The database system has two ''transactional data managers'' (''resource managers''), one on each node, and the database data are partitioned between the two data managers in a way that each has an exclusive control of its own (local to the node) portion of data: Each handles its own data and locks without any knowledge on the other manager's. For each distributed transaction such data managers need to execute the available [[atomic commitment]] protocol. 

Two distributed transactions, <math>T_{1}</math> and <math>T_{2}</math>, are running concurrently, and both access data x and y. x is under the exclusive control of the data manager on A (B's manager cannot access x), and y under that on B.

:<math>T_{1}</math> reads x on A and writes y on B, i.e., <math>T_{1} = R_{1A}(x)</math> <math>W_{1B}(y)</math>
:<math>T_{2}</math> reads y on B and writes x on A, i.e., <math>T_{2} = R_{2B}(y)</math> <math>W_{2A}(x)</math>

The respective local sub-transactions on A and B (the portions of <math>T_{1}</math> and <math>T_{2}</math> on each of the nodes) are the following:

:{| class="wikitable" style="text-align:center;"
|+Local sub-transactions
|-
! Sub-transaction !! A  !! B
|-
! <math>T_{1}</math>
|  <math>T_{1A}=R_{1A}(x)</math> || <math>T_{1B}=W_{1B}(y)</math>
|-
! <math>T_{2}</math>
| <math>T_{2A}=W_{2A}(x)</math> || <math>T_{2B}=R_{2B}(y)</math>

|}

The database system's [[Schedule (computer science)|schedule]] at a certain point in time is the following: 

:<math>R_{1A}(x)</math> <math>R_{2B}(y)</math>  
:(also <math>R_{2B}(y)</math> <math>R_{1A}(x)</math> is possible)

<math>T_{1}</math> holds a read-lock on x and <math>T_{2}</math> holds read-locks on y. Thus <math>W_{1B}(y)</math> and <math>W_{2A}(x)</math> are blocked by the [[Two-phase locking#Data-access locks|lock compatibility]] rules of SS2PL and cannot be executed. This is a distributed [[deadlock]] situation, which is also a voting-deadlock (see below) with a distributed (global) cycle of length 2 (number of edges, conflicts; 2 is the most frequent length). The local sub-transactions are in the following states:

:<math>T_{1A}</math> is ''ready'' (execution has ended) and ''voted'' (in atomic commitment)
:<math>T_{1B}</math> is ''running'' and blocked (no vote on it can occur)
:<math>T_{2B}</math> is ''ready'' and ''voted''
:<math>T_{2A}</math> is ''running'' and blocked (no vote).

Since the atomic commitment protocol cannot receive votes for blocked sub-transactions (a voting-deadlock), it will eventually abort some transaction with a missing vote(s) by [[timeout]], either <math>T_{1}</math>, or <math>T_{2}</math>, (or both, if the timeouts fall very close). This will resolve the global deadlock. The remaining transaction will complete running, be voted on, and committed.

'''Comments:''' 
:1. The data partition (x on A; y on B) is important since without it, for example, x can be accessed directly from B. If a transaction <math>T_{3}</math> is concurrently running on B with <math>T_{1}</math> and <math>T_{2}</math> and directly writes x, without a [[distributed lock manager]] the read-lock for x held by <math>T_{1}</math> on A is not visible on B and cannot  block the write of <math>T_{3}</math> (or signal a conflict for a non-blocking CO variant; see below). Thus serializability can be violated.
:2. Due to data partition, x cannot be accessed directly from B, however a transaction running on B still can issue a write or read request of x. This request is communicated to the transaction's local sub-transaction on A (which is generated, if does not exist already) which issues this request to the local data manager on A.

====Variations====

In the scenario above both conflicts are ''non-materialized'', and the global voting-deadlock is reflected as a cycle in the global ''wait-for graph'' (but not in the global ''conflict graph''; see [[Commitment ordering#More on global cycles and voting-deadlocks|More on global cycles and voting-deadlocks]] above). However the database system can utilize any CO variant with exactly the same voting-deadlock situation, and same resolution. For example, if [[Commitment ordering#Strict CO (SCO)|SCO]] (below) is used by the distributed database system instead of SS2PL, then the two conflicts in the example are ''materialized'', all local sub-transactions are in ''ready'' states, and vote blocking occurs in the two transactions, one on each node, because of the CO voting rule: due to conflicts <math>T_{2A}=W_{2A}(x)</math> is not voted on before <math>T_{1A}=R_{1A}(x)</math> ends, and <math>T_{1B}=W_{1B}(y)</math> is not voted on before <math>T_{2B}=R_{2B}(y)</math> ends (see [[Commitment ordering#Enforcing global CO|Enforcing global CO]] above), which is a voting-deadlock. Now the ''conflict graph'' has the global cycle (all conflicts are materialized), and again it is resolved by the atomic commitment protocol, and distributed serializability is maintained. Unlikely for a distributed database system, but possible in principle (and occurs in a multi-database), A can employ SS2PL while B employs SCO. In this case the global cycle is neither in the wait-for graph nor in the serializability graph, but rather in the ''augmented conflict graph'' (the union of the two). The various combinations are summarized in the following table:

{| class="wikitable" style="text-align:center;"
|+Voting-deadlock situations
|-
!Case!! A  !! B !!Possible schedule!!Materialized<br>conflicts<br>on cycle!!Non-<br>materialized<br>conflicts!!<math>T_{1A}</math> =<br><math>R_{1A}(x)</math>!!<math>T_{1B}</math> =<br><math>W_{1B}(y)</math>!!<math>T_{2A}</math> =<br><math>W_{2A}(x)</math>!!<math>T_{2B}</math> =<br><math>R_{2B}(y)</math>  
|-
! 1
|SS2PL||SS2PL||<math>R_{1A}(x)</math> <math>R_{2B}(y)</math>|| 0 || 2 ||Ready<br>Voted||Running<br>(Blocked)||Running<br>(Blocked)||Ready<br>Voted 
|-
! 2
|SS2PL|| SCO ||<math>R_{1A}(x)</math> <math>R_{2B}(y)</math> <math>W_{1B}(y)</math>|| 1 || 1 ||Ready<br>Voted ||Ready<br>Vote blocked||Running<br>(Blocked)||Ready<br>Voted
|-
! 3
|SCO||SS2PL|| <math>R_{1A}(x)</math> <math>R_{2B}(y)</math> <math>W_{2A}(x)</math> || 1 || 1 ||Ready<br>Voted||Running<br>(Blocked)||Ready<br>Vote blocked||Ready<br>Voted
|-
! 4
|SCO||SCO||<math>R_{1A}(x)</math> <math>R_{2B}(y)</math> <math>W_{1B}(y)</math> <math>W_{2A}(x)</math>|| 2 || 0 ||Ready<br>Voted||Ready<br>Vote blocked ||Ready<br>Vote blocked||Ready<br>Voted
|}

:'''Comments:''' 
# Some limited order changes in the schedules above are possible, constrained by the orders in the transactions, but they do not change the rest of the table.
# Case 4 above is also an example for a typical voting-deadlock when [[Commitment ordering#Optimistic distributed CO|optimistic distributed CO]] is used (i.e, Case 4 is unchanged when Optimistic CO (OCO; see below) replaces SCO on both A and B): No data-access blocking occurs, and only materialized conflicts exist.

==CO variants: Interesting special cases and generalizations==

Special case schedule property classes (e.g., SS2PL and SCO below) are strictly contained in the CO class. The generalizing classes (ECO and MVCO) strictly contain the CO class (i.e., include also schedules that are not CO compliant). The generalizing variants utilize additional information for better concurrency and performance by relaxing constraints: ECO uses knowledge about transactions being local (i.e., confined to a single database), and MVCO uses availability of data versions values. Like CO, both generalizing variants do not interfere with any transaction's operation scheduling, and can be seamlessly combined with any relevant concurrency control mechanism.
 
===Strong strict two phase locking (SS2PL)===

'''Strong Strict Two Phase Locking''' ([[Two-phase locking#Strong strict two-phase locking|SS2PL]];  also referred to as ''Rigorousness'' or ''Rigorous scheduling'') means that both read and write locks of a transaction are released only after the transaction has ended (either committed or aborted). The set of SS2PL schedules is a [[proper subset]] of the set of CO schedules.
This property is widely utilized in database systems, and since it implies CO, databases that use it and participate in global transactions generate together a serializable global schedule (when using any atomic commitment protocol, which is needed for atomicity in a multi-database environment). No database modification or addition is needed in this case to participate in a CO distributed solution: The set of undecided transactions to be aborted before committing in the [[Commitment ordering#The algorithm|local generic CO algorithm]] above is empty because of the locks, and hence such an algorithm is unnecessary in this case. A transaction can be voted on by a database system immediately after entering a "ready" state, i.e., completing running its task locally. Its locks are released by the database system only after it is decided by the atomic commitment protocol, and thus the condition in the ''Global CO enforcing theorem'' above is kept automatically. Interestingly, if a local [[Timeout (telecommunication)|timeout]] mechanism is used by a database system to resolve (local) SS2PL deadlocks, then aborting blocked transactions breaks not only potential local cycles in the global conflict graph (real cycles in the augmented conflict graph), but also database system's potential global cycles as a side effect, if the [[atomic commitment]] protocol's abort mechanism is relatively slow. Such independent aborts by several entities typically may result in unnecessary aborts for more than one transaction per global cycle. The situation is different for a local ''wait-for graph'' based mechanisms: Such cannot identify global cycles, and the atomic commitment protocol will break the global cycle, if the resulting voting deadlock is not resolved earlier in another database.

Local SS2PL with atomic commitment implying global serializability can also be deduced directly: All transactions obey the [[2PL]] (SS2PL) rules.

===Strict CO (SCO)===

[[Image:SCO-VS-SS2PL.jpg|thumb|450px|'''Read-write conflict: SCO Vs. SS2PL'''. Duration of transaction T2 is longer with SS2PL than with SCO.

SS2PL delays write operation w2[x] of T2 until T1 commits, due to a lock on x by T1 following read operation r1[x]. If t time units are needed for transaction T2 after starting write operation w2[x] in order to reach ready state, than T2 commits t time units after T1 commits. However, SCO does not block w2[x], and T2 can commit immediately after T1 commits.]]

'''Strict Commitment Ordering''' (SCO; (Raz 1991c)) is the intersection of [[Schedule (computer science)#Strict|strictness]] (a special case of recoverability) and CO, and provides an upper bound for a schedule's concurrency when both properties exist. It can be implemented using blocking mechanisms (locking) similar to those used for the popular SS2PL with similar overheads.

Unlike SS2PL, SCO does not block on a read-write conflict but possibly blocks on commit instead. SCO and SS2PL have identical blocking behavior for the other two conflict types: write-read, and write-write. As a result SCO has shorter average blocking periods, and more concurrency (e.g., performance simulations of a single database for the most significant variant of ''[[locks with ordered sharing]],'' which is identical to SCO, clearly show this, with approximately 100% gain for some transaction loads; also for identical transaction loads SCO can reach higher transaction rates than SS2PL before ''[[lock thrashing]]'' occurs). More concurrency means that with given computing resources more transactions are completed in time unit (higher transaction rate, [[throughput]]), and the average duration of a transaction is shorter (faster completion; see chart). The advantage of SCO is especially significant during lock contention.

*'''The SCO Vs. SS2PL Performance Theorem'''
:SCO provides shorter average transaction completion time than SS2PL, if read-write conflicts exist. SCO and SS2PL are identical otherwise (have identical blocking behavior with write-read and write-write conflicts).


SCO is as practical as SS2PL since as SS2PL it provides besides serializability also strictness, which is widely utilized as a basis for efficient recovery of databases from failure. An SS2PL mechanism can be converted to an SCO one for better performance in a straightforward way without changing recovery methods.

SS2PL is a [[proper subset]] of SCO (which is another explanation why SCO is less constraining and provides more concurrency than SS2PL).

===Optimistic CO (OCO)===

For implementing '''[[Optimistic concurrency control|Optimistic]] commitment ordering''' (OCO) the [[Commitment ordering#A generic local CO algorithm|generic local CO algorithm]] above is utilized without data access blocking, and thus without local deadlocks. OCO without transaction or operation scheduling constraints covers the entire CO class, and is not a special case of the CO class, but rather a useful CO variant characterization.

See also [[Commitment ordering#Optimistic distributed CO|Optimistic distributed CO]] above: All data managers employ OCO.

===Extended CO (ECO)===

====General characterization of ECO==== 

'''Extended Commitment Ordering''' (ECO; (Raz 1993a)) generalizes CO. When local transactions (transactions confined to a single database) can be distinguished from global (distributed) transactions (transactions that span two databases or more), commitment order is applied to global transactions only. Thus, for a local (to a database) schedule to have the ECO property, the chronological (partial) order of commit events of global transactions only (unimportant for local transactions) is consistent with their order on the respective local conflict graph. 

*'''Definition - Extended commitment ordering'''

:Let <math>T_{1}, T_{2}</math> be two committed ''global'' transactions in a schedule, such that a ''directed path'' of unaborted transactions exists in the ''conflict graph'' ([[precedence graph]]) from <math>T_{1}</math> to <math>T_{2}</math> (<math>T_{1}</math> precedes <math>T_{2}</math>, possibly [[transitive relation|transitively]], indirectly). The schedule has the '''Extended commitment ordering''' (ECO) property, if for every two such transactions <math>T_{1}</math> commits before <math>T_{2}</math> commits.


A distributed algorithm to guarantee global ECO exists. As for CO, the algorithm needs only (unmodified) [[atomic commitment]] protocol messages. In order to guarantee global serializability, each database needs to guarantee also the conflict serializability of its own transactions by any (local) concurrency control mechanism. 

* '''The ECO and Global Serializability Theorem'''

:(Local, which implies global) ECO together with local conflict serializability, is a sufficient condition to guarantee global conflict serializability. When no concurrency control information beyond atomic commitment messages is shared outside a database (autonomy), and local transactions can be identified, it is also a necessary condition. 


This condition (ECO with local serializability) is weaker than CO, and allows more concurrency at the cost of a little more complicated local algorithm (however, no practical overhead difference with CO exists).

When all the transactions are assumed to be global (e.g., if no information is available about transactions being local), ECO reduces to CO.

====The ECO algorithm==== 

Before a global transaction is committed, a generic local (to a database) ECO algorithm aborts a minimal set of undecided transactions (neither committed, nor aborted; either local transactions, or global that run locally), that can cause later a cycle in the conflict graph. This set of aborted transactions (not unique, contrary to CO) can be optimized , if each transaction is assigned with a weight (that can be determined by transaction's importance and by the computing resources already invested in the running transaction; optimization can be carried out, for example, by a reduction from the ''[[Max flow in networks]]'' problem). Like for CO such a set is time dependent, and becomes empty eventually. Practically, almost in all needed implementations a transaction should be committed only when the set is empty (and no set optimization is applicable). The local (to the database) concurrency control mechanism (separate from the ECO algorithm) ensures that local cycles are eliminated (unlike with CO, which implies serializability by itself; however, practically also for CO a local concurrency mechanism is utilized, at least to ensure Recoverability). Local transactions can be always committed concurrently (even if a precedence relation exists, unlike CO). When the overall transactions' local partial order (which is determined by the local conflict graph, now only with possible temporary local cycles, since cycles are eliminated by a local serializability mechanism) allows, also global transactions can be voted on to be committed concurrently (when all their [[transitive relation|transitively]] (indirect) preceding (via conflict) ''global'' transactions are committed, while transitively preceding local transactions can be at any state. This in analogy to the distributed CO algorithm's stronger concurrent voting condition, where all the transitively preceding transactions need to be committed).

The condition for guaranteeing ''Global ECO'' can be summarized similarly to CO:

*'''The Global ECO Enforcing Theorem'''

:Let <math>T_{1}, T_{2}</math> be undecided (neither committed nor aborted) ''global transactions'' in a database system that ensures serializability locally, such that a ''directed path'' of unaborted transactions exists in the ''local conflict graph'' (that of the database itself) from <math>T_{1}</math> to <math>T_{2}</math>. Then, having <math>T_{1}</math> ended (either committed or aborted) before <math>T_{2}</math> is voted on to be committed, in every such database system in a multidatabase environment, is a [[necessary and sufficient condition]] for guaranteeing Global ECO (the condition guarantees Global ECO, which may be violated without it).


Global ECO (all global cycles in the global conflict graph are eliminated by atomic commitment) together with Local serializability (i.e., each database system maintains serializability locally; all local cycles are eliminated) imply Global serializability (all cycles are eliminated).

Similarly to CO as well, the ECO ''voting-deadlock'' situation can be summarized as follows:

*'''The ECO Voting-Deadlock Theorem'''

:Let a multidatabase environment comprise database systems that enforce, each, both ''Global ECO'' (using the condition in the theorem above) and ''local conflict serializability'' (which eliminates local cycles in the global conflict graph). Then, a ''voting-deadlock'' occurs [[if and only if]] a ''global cycle'' (spans two or more databases) exists in the ''Global augmented conflict graph'' (also blocking by a data-access lock is represented by an edge). If the cycle does not break by any abort, then all the ''global transactions'' on it are involved with the respective voting-deadlock, and eventually each has its vote blocked (either directly, or indirectly by a data-access lock). If a local transaction resides on the cycle, it may be in any unaborted state (running, ready, or committed; unlike CO no local commit blocking is needed).


As with CO this means that also global deadlocks due to data-access locking (with at least one lock blocking) are voting deadlocks, and are automatically resolved by atomic commitment.

===Multi-version CO (MVCO)===

'''Multi-version Commitment Ordering''' (MVCO; (Raz 1993b)) is a generalization of CO for databases with multi-version resources (data). With such resources ''read-only transactions'' do not block or being blocked for better performance. MVCO implies ''One-copy-serializability'' (1SER or 1SR) which is the generalization of [[serializability]] for multi-version resources. In the introduced underlying theory for MVCO conflicts are generalized for different versions of a same resource. For different versions conflict chronological order is replaced by version order, and possibly reversed, while keeping the usual definitions for conflicting operations. Results for the regular and augmented conflict graphs remain unchanged, and similarly to CO a distributed MVCO enforcing algorithm exists, now for a mixed environment with both single-version and multi-version resources (now single-version is a special case of multi-version). As for CO, the algorithm needs only (unmodified) [[atomic commitment]] protocol messages with no additional communication overhead. In analogy to CO the following holds:

*'''The MVCO and Global one-copy-serializability Theorem'''

:MVCO compliance of every ''autonomous'' database system (or transactional object) in a mixed multidatabase environment of single-version and multi-version databases is a ''necessary condition'' for guaranteeing Global one-copy-serializability (1SER). MVCO compliance of every database system is a ''sufficient condition'' for guaranteeing Global 1SER.

:'''Comment''': Now a CO compliant single-version database system is automatically also MVCO compliant.


MVCO can be further generalized to employ the generalization of ECO.

See also [[Multiversion concurrency control]].

===CO and its variants are transparently interoperable for global serializability===

With CO and its variants (e.g., SS2PL, SCO, OCO, ECO, and MVCO above) global serializability is achieved via ''[[atomic commitment]]'' protocol based distributed algorithms. For CO and all its variants atomic commitment protocol is the instrument to eliminate global cycles (cycles that span two or more databases) in the ''global augmented'' (and thus also regular) ''conflict graph'' (implicitly; no global data structure implementation is needed). In cases of either incompatible local commitment orders in two or more databases (when no global [[partial order]] can embed the respective local partial orders together), or a data-access locking related voting deadlock, both implying a global cycle in the global augmented conflict graph and missing votes, the atomic commitment protocol breaks such cycle by aborting an undecided transaction on it (see [[commitment ordering#The distributed CO algorithm|The distributed CO algorithm]] above). Differences between the various variants exist at the local level only (within the participating database systems). Each local CO instance of any variant has the same role, to determine the position of every global transaction (a transaction that spans two or more databases) within the local commitment order, i.e., to determine when it is the transaction's turn to be voted on locally in the atomic commitment protocol. Thus, all the CO variants exhibit the same behavior in regard to atomic commitment. This means that they are all interoperable via atomic commitment (using the same software [[interface (computer science)|interfaces]], some already [[international standard|standardized]] for atomic commitment, primarily for the [[two phase commit]] protocol, e.g., [[X/Open XA]]) and transparently can be utilized together in any distributed environment (while each CO variant instance is possibly associated with any relevant local concurrency control mechanism type). 

In summary, any single global transaction can participate simultaneously in databases that may employ each any, possibly different, CO variant (while concurrently running processes in each such database, and running concurrently with local and other global transactions in each such database). The atomic commitment protocol is indifferent to CO, and does not distinguish between the various CO variants. Any ''global cycle'' generated in the augmented global conflict graph may span databases of different CO variants, and generate (if not broken by any local abort) a voting deadlock that is resolved by atomic commitment exactly the same way as in a single CO variant environment. ''local cycles'' (now possibly with mixed materialized and non-materialized conflicts, both serializability and data-access-locking deadlock related, e.g., SCO) are resolved locally (each by its respective variant instance's own local mechanisms).

*'''The CO Variants Interoperability Theorem'''
:In a multi database environment, where each database system is compliant with some CO variant property, any global transaction can participate simultaneously in databases of possibly different CO variants, and Global serializability is guaranteed (and Global one-copy-serializability (1SER), for a case when a multi-version database exists).

:Furthermore, data-access-locking related global deadlocks are resolved automatically (each such deadlock is generated by a global cycle in the ''augmented conflict graph'' (see above), involving at least one data-access lock (non-materialized conflict) and two database systems; thus, not a cycle in the regular conflict graph and does not affect serializability).

==See also==

*[[Serializability]]
*[[Global serializability]]

==References==

*Yoav Raz (1992): [http://www.informatik.uni-trier.de/~ley/db/conf/vldb/Raz92.html  ''The Principle of Commitment Ordering, or Guaranteeing Serializability in a Heterogeneous Environment of Multiple Autonomous Resource Managers Using Atomic Commitment.'']  Proceedings of the Eighteenth International Conference on Very Large Data Bases (VLDB), pp. 292-312, Vancouver, Canada, August 1992. (also DEC-TR 841, [[Digital Equipment Corporation]], November 1990)

*[http://www.vldb.org/conf/1992/P292.PDF  Download/view the VLDB 1992 article (PDF)]

*Yoav Raz (1991a): US patents [http://patft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=3&f=G&l=50&co1=AND&d=PTXT&s1=%22commitment+ordering%22.TI.&OS=TTL/ 5,504,899 (ECO)]  [http://patft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=2&f=G&l=50&co1=AND&d=PTXT&s1=%22commitment+ordering%22.TI.&OS=TTL/ 5,504,900 (CO)]  [http://patft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&co1=AND&d=PTXT&s1=%22commitment+ordering%22.TI.&OS=TTL/ 5,701,480 (MVCO)]

*Yoav Raz (1994): [http://www.informatik.uni-trier.de/~ley/db/journals/ipl/ipl51.html#Raz94 ''Serializability by Commitment Ordering.''] ''Information Processing Letters'' (IPL), Volume 51, Number 5,  pp. 257-264, September 1994. (Received August 1991)

-----------

*Yoav Raz (1991b): ''The Commitment Order Coordinator (COCO) of a Resource Manager, or Architecture for Distributed Commitment Ordering Based Concurrency Control'', DEC-TR 843, Digital Equipment Corporation, December 1991. 

*Yoav Raz (1991c): ''Locking Based Strict Commitment Ordering, or How to improve Concurrency in Locking Based Resource Managers'', DEC-TR 844, December 1991.  

*Yoav Raz (1993a): [http://portal.acm.org/citation.cfm?id=153858 ''Extended Commitment Ordering or Guaranteeing Global Serializability by Applying Commitment Order Selectivity to Global Transactions,''] Proceedings of the Twelfth ACM Symposium on Principles of Database Systems (PODS), Washington, DC, pp. 83-96, May 1993. (also DEC-TR 842, November 1991)

*Yoav Raz (1993b): [http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=281924  ''Commitment Ordering Based Distributed Concurrency Control for Bridging Single and Multi Version Resources,''] Proceedings of the Third IEEE International Workshop on Research Issues on Data Engineering: Interoperability in Multidatabase Systems (RIDE-IMS), Vienna, Austria, pp. 189-198, April 1993.(also DEC-TR 853, July 1992) 



[[Category:Data management]]
[[Category:Databases]]
[[Category:Transaction processing]]
[[Category:Concurrency control]]
[[Category:Distributed algorithms]]
