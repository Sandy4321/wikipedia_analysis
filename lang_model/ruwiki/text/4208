[[Файл:Motorola 6800 Assembly Language.png|thumb|250px|Листинг программы на языке ассемблера Motorola MC6800 (слева идут адреса и машинные коды в [[Шестнадцатеричная система счисления|шестнадцатеричной системе]], вычисленные и сгенерированные ассемблером из исходного кода программы, справа показан сам текст программы с мнемоническими инструкциями, метками, директивами, выражениями и комментариями)]]

'''Язы́к ассе́мблера''' ({{lang-en|assembly language}}) — машинно-ориентированный [[Низкоуровневый язык программирования|язык низкого уровня]] с командами, не всегда соответствующими [[Код операции|командам машины]], который может обеспечить дополнительные возможности вроде [[макрокоманда|макрокоманд]]<ref>СТ ИСО 2382/7-77 // {{книга|заглавие=Вычислительная техника. Терминология: Справочное пособие. Выпуск 1|ответственный=Рецензент канд. техн. наук Ю. П. Селиванов|место=М.|издательство=Издательство стандартов|год=1989|страниц=168|isbn=5-7050-0155-X|тираж=55&nbsp;000}}</ref>; автокод, расширенный конструкциями [[Высокоуровневый язык программирования|языков программирования высокого уровня]], такими как выражения, макрокоманды, средства обеспечения [[Модульность (программирование)|модульности программ]]<ref name="ГОСТ 19781-83">ГОСТ 19781-83 // {{книга|заглавие=Вычислительная техника. Терминология: Справочное пособие. Выпуск 1|ответственный=Рецензент канд. техн. наук Ю. П. Селиванов|место=М.|издательство=Издательство стандартов|год=1989|страниц=168|isbn=5-7050-0155-X|тираж=55&nbsp;000}}</ref>.<br /> '''Автокод''' — язык программирования, предложения которого по своей структуре в основном подобны командам и обрабатываемым данным конкретного [[Машинный код|машинного языка]]<ref name="ГОСТ 19781-83" />.

Язык ассемблера — система обозначений, используемая для представления в удобочитаемой <!--удобночитаемой — просторечие — ДИ-->форме программ, записанных в машинном коде. Язык ассемблера позволяет программисту пользоваться алфавитными мнемоническими кодами операций, по своему усмотрению присваивать символические имена [[Регистр процессора|регистрам ЭВМ]] и памяти, а также задавать удобные для себя схемы [[Адресация памяти|адресации]] (например, индексную или косвенную). Кроме того, он позволяет использовать различные системы счисления (например, [[Десятичная система счисления|десятичную]] или [[Шестнадцатеричная система счисления|шестнадцатеричную]]) для представления числовых констант и даёт возможность помечать строки программы метками с символическими именами с тем, чтобы к ним можно было обращаться (по именам, а не по адресам) из других частей программы (например, для передачи управления)<ref>{{книга|заглавие=Толковый словарь по вычислительным системам|оригинал=Dictionary of Computing|ответственный=Под ред. В. Иллингуорта и др.: Пер. с англ. А. К. Белоцкого и др.; Под ред. Е. К. Масловского|место=М.|издательство=Машиностроение|год=1990|страниц=560|isbn=5-217-00617-X (СССР), ISBN 0-19-853913-4 (Великобритания)|тираж=70&nbsp;000 (доп.)}}</ref>.

Перевод программы на языке ассемблера в исполнимый [[машинный код]] (вычисление выражений, раскрытие макрокоманд, замена мнемоник собственно машинными кодами и символьных адресов на [[Адрес (информатика)#абсолютный|абсолютные]] или [[Адрес (информатика)#относительный|относительные адреса]]) производится ''[[ассемблер]]ом'' — программой-транслятором, которая и дала языку ассемблера его название.

== Содержание языка ==
Команды языка ассемблера один к одному соответствуют командам [[процессор]]а. Фактически, они и представляют собой более удобную для человека символьную форму записи — ''мнемокоды'' — команд и их [[аргумент (программирование)|аргументов]]. При этом одной команде языка ассемблера может соответствовать несколько вариантов команд процессора<ref>{{cite web|author=Крис Касперски.|title=Образ мышления IDA|url=http://www.samvel.net/text/lib/00034542.txt|archiveurl=http://www.webcitation.org/617cdiOd6|archivedate=2011-08-22}}</ref>.

Кроме того, язык ассемблера позволяет использовать символические [[метка (программирование)|метки]] вместо адресов ячеек памяти, которые при ассемблировании заменяются на вычисляемые ассемблером или компоновщиком [[Адрес (информатика)#абсолютный|абсолютные]] или [[Адрес (информатика)#относительный|относительные адреса]], а также так называемые ''[[Директивы ассемблера|директивы]]'' (команды ассемблера, не переводимые в машинные команды процессора, а выполняемые самим ассемблером).

Директивы ассемблера позволяют, в частности, включать блоки данных, задать ассемблирование фрагмента программы по условию, задать значения меток, использовать [[Макрос в языке ассемблера|макрокоманды]] с параметрами.

Каждая модель (или семейство) процессоров имеет свой набор — [[система команд|систему]] — команд и соответствующий ему язык ассемблера. Наиболее популярные синтаксисы языков ассемблера — [[Intel-синтаксис]] и [[AT&T-синтаксис]].

Существуют компьютеры, реализующие в качестве машинного язык программирования высокого уровня ([[Форт (язык программирования)|Форт]], [[Лисп]], Эль-76). Фактически, в таких компьютерах они выполняют роль языков ассемблера.

== Достоинства и недостатки ==

=== Достоинства ===
* Язык ассемблера позволяет писать самый быстрый и компактный код, какой вообще возможен для данного процессора.
* Если код программы достаточно большой, — данные, которыми он оперирует, не помещаются целиком в [[регистр процессора|регистрах процессора]], то есть частично или полностью находятся в [[Оперативная память|оперативной памяти]], — то искусный программист, как правило, способен значительно оптимизировать программу по сравнению с транслятором с языка высокого уровня по одному или нескольким параметрам и создать код близкий к [[Эффективность по Парето|оптимальному по Парето]] (как правило, быстродействие программы достигается за счет удлинения кода и наоборот):
** скорость работы — за счёт оптимизации вычислительного алгоритма и/или более рационального обращения к [[Оперативная память|оперативной памяти (ОП)]] (например, если все исходные данные хранятся в регистрах процессора, то можно исключить излишние обращения к ОП), перераспределения данных, табличного вычисления функций;
** объём кода (в том числе за счёт эффективного использования промежуточных результатов). Сокращение объёма кода также нередко повышает скорость выполнения программы.
* Обеспечение максимального использования специфических возможностей конкретной платформы, что также позволяет создавать более эффективные программы, в том числе менее ресурсоёмкие.
* При программировании на языке ассемблера возможен непосредственный доступ к аппаратуре, и, в частности, [[порт ввода-вывода|портам ввода-вывода]], регистрам процессора и др. Во многих операционных системах прямое обращение из прикладных программ для записи в регистры периферийного оборудования блокировано для надёжности работы системы и исключения «зависаний».
* Язык ассемблера часто применяется для создания [[драйвер]]ов оборудования и [[Ядро операционной системы|ядра операционной системы]] (или машиннозависимых подсистем ядра ОС), тогда, когда важно временно́е согласование работы периферийных устройств с центральным процессором.
* Язык ассемблера используется для создания «[[прошивка|прошивок]]» [[BIOS]].
* С помощью языка ассемблера часто создаются машиннозависимые подпрограммы [[компилятор]]ов и [[интерпретатор]]ы [[Язык программирования высокого уровня|языков высокого уровня]], а также реализуется совместимость [[Аппаратная платформа компьютера|платформ]].
* С помощью программы [[дизассемблер]]а можно понять алгоритмы работы исследуемой программы при отсутствии листинга на высокоуровневом языке, изучая только машинные коды, но в сложных нетривиальных программах это очень и очень трудоёмко.

=== Недостатки ===
* В силу машинной ориентации («низкого» уровня) языка ассемблера человеку сложнее читать и понимать программу на нём по сравнению с языками программирования высокого уровня; программа состоит из слишком «мелких» элементов — машинных команд, соответственно, усложняются программирование и отладка, растут трудоёмкость и вероятность внесения ошибок.
* Требуется повышенная квалификация программиста для получения качественного кода: код, написанный средним программистом на языке ассемблера, обычно оказывается не лучше или даже хуже кода, порождаемого [[Оптимизирующий компилятор|оптимизирующим компилятором]] для сравнимых программ, написанных на языке высокого уровня<ref>{{cite web|author=Крис Касперски.|title=Война миров: Ассемблер против Си|url=http://www.insidepro.com/kk/145/145r.shtml|accessdate=1 июня 2010|archiveurl=http://www.webcitation.org/617ceCi4u|archivedate=2011-08-22}}</ref>.
* Программа на языке высокого уровня может быть перекомпилирована с автоматической оптимизацией под особенности новой целевой платформы<ref>Например, доступ к данным, [[Выравнивание данных|невыровненным]] на границу 32-битных слов в архитектуре [[IA-32]], требует дополнительного времени. Также, в архитектуре [[Intel P6]] появились два конвейера, и, чтобы они не {{translation2|простой конвейера|простаивали|en|Pipeline stall}}, может потребоваться {{translation|:en:Compiler optimization#Factors affecting optimization|переупорядочивание инструкций}}</ref>, программа же на языке ассемблера на новой платформе может потерять своё преимущество в скорости без ручного переписывания кода<ref>{{cite web|author=Кирилл Кочетков.|title=MP3-кодек LAME — продолжаем исследования|url=http://www.ixbt.com/cpu/lame-exam-2.shtml|publisher=[[iXBT]]|date=28 ноября 2003|accessdate=1 июня 2010|archiveurl=http://www.webcitation.org/67ytIpejk|archivedate=2012-05-28}}</ref><ref>{{cite web|author=Serj Kalichev.|title=Основы написания переносимого кода|url=http://www.opennet.ru/base/dev/porting_code.txt.html|accessdate=1 июня 2010|description=Оригинал статьи: Martin Husemann. Fighting the Lemmings|archiveurl=http://www.webcitation.org/67ytKUoAy|archivedate=2012-05-28}}</ref>.
* Как правило, меньшее количество доступных [[библиотека (программирование)|библиотек]] по сравнению с современными индустриальными языками программирования.
* Отсутствует переносимость программ на компьютеры с другой архитектурой и системой команд.

== Применение ==
Исторически, если первым поколением языков программирования считать машинные коды, то язык ассемблера можно рассматривать как второе поколение языков программирования. Недостатки языка ассемблера, сложность разработки на нём больших программных комплексов привели к появлению языков третьего поколения — [[Высокоуровневый язык программирования|языков программирования высокого уровня]] (таких как [[Фортран]], [[Лисп]], [[Кобол]], [[Паскаль (язык программирования)|Паскаль]], [[Си (язык программирования)|Си]] и др.). Именно языки программирования высокого уровня и их наследники в основном используются в настоящее время в индустрии [[информационные технологии|информационных технологий]]. Однако, языки ассемблера сохраняют свою нишу, обусловленную их уникальными преимуществами в части эффективности и возможности полного использования специфических средств конкретной платформы.

На языке ассемблера пишут программы или их фрагменты в тех случаях, когда критически важны:
* быстродействие ([[драйвер]]ы, игры);
* объём используемой памяти (загрузочные секторы, встраиваемое ({{lang-en|embedded}}) программное обеспечение, программы для [[микроконтроллер]]ов и процессоров с ограниченными ресурсами, [[компьютерный вирус|вирусы]], программные защиты).

С использованием программирования на языке ассемблера производятся:
* Оптимизация критичных к скорости участков программ в программах на языках высокого уровня, таких как [[C++]] или [[Pascal]]. Это особенно актуально для [[Игровая приставка|игровых приставок]], имеющих фиксированную производительность, и для [[мультимедиа|мультимедийных]] [[кодек]]ов, которые стремятся делать менее ресурсоёмкими и более быстрыми.
* Создание [[операционная система|операционных систем]] (ОС) или их компонентов. В настоящее время подавляющее большинство ОС пишут на более высокоуровневых языках (в основном на [[Си (язык программирования)|Си]] — языке высокого уровня, который специально был создан для написания одной из первых версий [[UNIX]]). Аппаратно зависимые участки кода, такие как [[Загрузчик операционной системы|загрузчик ОС]], уровень [[Слой аппаратных абстракций|абстрагирования от аппаратного обеспечения]] (hardware abstraction layer) и ядро, часто пишутся на языке ассемблера. Фактически, ассемблерного кода в ядрах [[Windows]] или [[Linux (ядро)|Linux]] совсем немного, поскольку авторы стремятся обеспечить [[Портирование программного обеспечения|переносимость]] и [[надёжность]], но, тем не менее, он там присутствует. Некоторые любительские ОС, такие как [[MenuetOS]] и [[KolibriOS]], целиком написаны на языке ассемблера. При этом MenuetOS и [[KolibriOS]] помещается на дискету и содержит графический многооконный интерфейс.
* Программирование [[микроконтроллер]]ов (МК) и других встраиваемых процессоров. По мнению профессора [[Таненбаум, Эндрю|Таненбаума]], развитие МК повторяет историческое развитие компьютеров новейшего времени<ref>Эндрю Таненбаум. Архитектура компьютера. 5-е изд.</ref>. Сейчас (2013 г.) для программирования МК весьма часто применяют язык ассемблера (хотя и в этой области широкое распространение получают языки вроде Си). В МК приходится перемещать отдельные [[байт]]ы и [[бит]]ы между различными [[ячейка памяти|ячейками памяти]]. Программирование МК весьма важно, так как, по мнению Таненбаума, в автомобиле и квартире современного цивилизованного человека в среднем содержится 50 микроконтроллеров<ref>Эндрю Таненбаум. Архитектура компьютера. 3-е изд.</ref>.
* Создание [[драйвер]]ов. Драйверы (или их некоторые программные модули) программируют на языке ассемблера. Хотя, в настоящее время, драйверы также стремятся писать на языках высокого уровня (на высокоуровневом языке много проще написать надёжный драйвер), в связи с повышенными требованиями к надёжности, и достаточной производительностью современных процессоров (быстродействие обеспечивает временно́е согласование процессов в устройстве и процессоре) и достаточным совершенством компиляторов с языков высокого уровня (отсутствие ненужных пересылок данных в сгенерированном коде), подавляющая часть современных драйверов пишется на языке ассемблера. Надёжность для драйверов играет особую роль, поскольку в [[Windows NT]] и [[UNIX]] (в том числе в [[Linux]]) драйверы работают в режиме ядра системы. Одна тонкая ошибка в драйвере может привести к краху всей системы.
* Создание [[антивирусная программа|антивирусов]] и других защитных программ.
* Написание [[транслятор]]ов языков программирования.

=== Связывание программ на разных языках ===
Поскольку уже давно на языке ассемблера часто кодируют только фрагменты программ, их необходимо [[связывание программ|связывать]] с остальными частями программной системы, написанными на других языках программирования. Это достигается двумя основными способами:
* На этапе компиляции — вставка в исходный код программы на языке высокого уровня ассемблерных фрагментов ({{lang-en|inline assembler}}) с помощью специальных директив языка. Способ удобен для несложных преобразований данных, но полноценного ассемблерного кода, с данными и подпрограммами, включая подпрограммы со множеством входов и выходов, не поддерживаемых языком высокого уровня, с его помощью сделать невозможно.
* На этапе [[Компоновщик|компоновки]] при [[Компилятор#Раздельная компиляция|раздельной компиляции]]. Для взаимодействия компонуемых модулей достаточно, чтобы импортируемые функции (определённые в одних модулях и используемые в других) поддерживали определённое [[соглашение о вызове]] ({{lang-en|calling conventions}}). Написаны же отдельные модули могут быть на любых языках, в том числе и на языке ассемблера.

== Синтаксис ==
Синтаксис языка ассемблера определяется системой команд конкретного процессора.

=== Набор команд ===
Типичными командами языка ассемблера являются (большинство примеров даны для [[Intel-синтаксис]]а архитектуры [[x86]]):

* Команды пересылки данных (<code>mov</code> и др.)
* Арифметические команды (<code>add</code>, <code>sub</code>, <code>imul</code> и др.)
* Логические и побитовые операции (<code>or</code>, <code>and</code>, <code>xor</code>, <code>shr</code> и др.)
* Команды управления ходом выполнения программы (<code>jmp</code>, <code>loop</code>, <code>ret</code> и др.)
* Команды вызова [[Прерывание|прерываний]] (иногда относят к командам управления): <code>int</code>
* Команды ввода-вывода в [[порт ввода-вывода|порты]] (<code>in</code>, <code>out</code>)
* Для микроконтроллеров и [[микрокомпьютер]]ов характерны также команды, выполняющие проверку и переход по условию, например:
:* <code>cjne</code> — перейти, если не равно
:* <code>djnz</code> — декрементировать, и если результат ненулевой, то перейти
:* <code>cfsneq</code> — сравнить, и если не равно, пропустить следующую команду

=== Инструкции ===

=== Типичный формат записи команд: ===
<source lang="asm">[метка:] мнемокод [операнды] [;комментарий]</source>

где ''мнемокод'' — непосредственно [[мнемоника]] инструкции процессору. К ней могут быть добавлены префиксы (повторения, изменения типа адресации и пр.).

В качестве [[операнд]]ов могут выступать [[Константа (программирование)|константы]], адреса [[Регистр процессора|регистров]], адреса в [[Оперативная память|оперативной памяти]] и пр. Различия между синтаксисом [[Intel-синтаксис|Intel]] и [[AT&T-синтаксис|AT&T]] касаются в основном порядка перечисления операндов и указания различных [[Адресация памяти|методов адресации]].

Используемые мнемоники обычно одинаковы для всех процессоров одной архитектуры или семейства архитектур (среди широко известных — мнемоники процессоров и контроллеров [[x86]], [[ARM (архитектура)|ARM]], [[SPARC]], [[PowerPC]], [[Motorola 680x0|M68k]]). Они описываются в спецификации процессоров. Возможные исключения:
* если ассемблер использует кроссплатформенный AT&T-синтаксис (оригинальные мнемоники приводятся к синтаксису AT&T);
* если изначально существовало два стандарта записи мнемоник (система команд была наследована от процессора другого производителя).

Например, процессор [[Zilog Z80]] наследовал систему команд [[8080|Intel 8080]], расширил её и поменял мнемоники (и обозначения регистров) на свой лад. Процессоры [[Motorola Fireball]] наследовали систему команд Z80, несколько её урезав. Вместе с тем, [[Motorola]] официально вернулась к мнемоникам [[Intel]] и в данный момент половина ассемблеров для Fireball работает с мнемониками Intel, а половина — с мнемониками Zilog.

=== Директивы ===
Программа на языке ассемблера может содержать ''директивы'': инструкции, не переводящиеся непосредственно в машинные команды, а управляющие работой компилятора. Набор и синтаксис их значительно разнятся и зависят не от аппаратной платформы, а от используемого транслятора (порождая диалекты языков в пределах одного семейства архитектур). В качестве «джентльменского набора» директив можно выделить следующие:
* определение данных (констант и переменных),
* управление организацией программы в памяти и параметрами выходного файла,
* задание режима работы компилятора,
* всевозможные абстракции (то есть элементы языков высокого уровня) — от оформления процедур и функций (для упрощения реализации парадигмы [[процедурное программирование|процедурного программирования]]) до условных конструкций и циклов (для парадигмы [[структурное программирование|структурного программирования]]),
* [[макрос в языке ассемблера|макросы]].

=== Пример программы ===
Примеры программы [[Hello, world!]] для разных платформ и разных диалектов:
{{Hider hiding
|title=Пример [[.COM | COM]]-программы для [[MS-DOS]] на диалекте [[TASM]]
|content=
<source lang="asm"> 
.MODEL TINY
CODE SEGMENT
ASSUME CS:CODE, DS:CODE
ORG 100h
START:
        mov ah,9
        mov dx,OFFSET Msg
        int 21h
        int 20h
        Msg DB 'Hello World',13,10,'$'
CODE ENDS
END START
</source>
}}

{{Hider hiding
|title=Пример [[.EXE | EXE]]-программы для [[MS-DOS]] на диалекте [[TASM]]
|content=
<source lang="asm"> 
.MODEL SMALL
.DATA
        msg DB 'Hello World',13,10,'$'
.CODE
START:
        mov ax, @DATA
        mov ds, ax
        mov ax, 0900h
        lea dx, msg
        int 21h
        mov ax, 4C00h
        int 21h
END START
</source>
}}
{{Hider hiding
|title=Пример программы для [[Linux]]/[[x86]] на диалекте [[NASM]]
|content=
<source lang="asm"> 
SECTION .data
msg: db "Hello, world",10
len: equ $-msg
 
SECTION .text
global _start
_start: mov edx, len
        mov ecx, msg
        mov ebx, 1    ; stdout
        mov eax, 4    ; write(2)
        int 0x80

        mov ebx, 0
        mov eax, 1    ; exit(2)
        int 0x80
</source>
}}

{{Hider hiding
|title=Пример программы для [[FreeBSD]]/[[x86]] на диалекте [[NASM]]
|content=
<source lang="asm"> 
SECTION .data
msg: db "Hello, world",10
len: equ $-msg
 
SECTION .text
global _start

syscall: int 0x80
         ret

_start:  push len
         push msg
         push 1        ; stdout
         mov eax, 4    ; write(2)
         call syscall
         add esp, 3*4

         push 0
         mov eax, 1    ; exit(2)
         call syscall
</source>
}}

{{Hider hiding
|title=Пример программы для [[Microsoft Windows]] на диалекте [[MASM]]
|content=
<source lang="asm"> 
.386
.model flat, stdcall
option casemap:none
include \masm32\include\windows.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib
 
.data
        msg db "Hello, world", 13, 10
        len equ $-msg
 
.data?
        written dd ?
 
.code
start:
        push    -11
        call    GetStdHandle
 
        push    0
        push    OFFSET written
        push    len
        push    OFFSET msg
        push    eax
        call    WriteFile
 
        push    0
        call    ExitProcess

end start

</source>
}}
{{Hider hiding
|title=Пример консольной программы для Windows на диалекте [[Fasm|FASM]]
|content=
<source lang="asm">
format PE console
entry start

include 'include\win32a.inc'

section '.data' data readable writeable
message db 'Hello, world!',0
section '.code' code readable executable
start:
; CINVOKE макрос в составе FASM.
; Позволяет вызывать CDECL-функции. 
  cinvoke printf,message 
  cinvoke getch
; INVOKE аналогичный макрос для STDCALL-функций. 
  invoke ExitProcess,0
section '.idata' import data readable
library kernel,'kernel32.dll',\
	msvcrt,'msvcrt.dll'

import kernel,\
       ExitProcess,'ExitProcess'

import msvcrt,\
       printf,'printf',\
       getch,'_getch'
</source>
}}
{{Hider hiding
|title=Пример 64-битной программы для Windows на диалекте [[Yasm|YASM]] (c использованием линковщика от Microsoft)
|content=
<source lang="asm">
;yasm-1.0.0-win32.exe -f win64 HelloWorld_Yasm.asm
;setenv /Release /x64 /xp
;link HelloWorld_Yasm.obj Kernel32.lib User32.lib /entry:main /subsystem:windows /LARGEADDRESSAWARE:NO
bits 64

global main

extern MessageBoxA
extern ExitProcess

section .data
mytit db 'The 64-bit world of Windows & assembler...', 0
mymsg db 'Hello World!', 0

section .text
main:
mov r9d, 0       ; uType = MB_OK
mov r8,  mytit   ; LPCSTR lpCaption
mov rdx, mymsg   ; LPCSTR lpText
mov rcx, 0       ; hWnd = HWND_DESKTOP
call MessageBoxA
mov ecx, eax     ; uExitCode = MessageBox(...)
call ExitProcess

ret
</source>
}}
{{Hider hiding
|title=Пример программы для [[Solaris]] и архитектуры [[SPARC]]
|content=
<source lang="asm">

.section ".data"
hello:	.asciz "Hello World!\n"

.section ".text"

.align	4
.global	main

main:
save	%sp, -96, %sp	! выделяем память

mov	4, %g1	! 4 = WRITE (системный вызов)
mov	1, %o0	! 1 = STDOUT
set	hello, %o1
mov	14, %o2	! количество символов
ta	8	! вызов системы

! выход из программы
mov	1, %g1	! move 1(exit() syscall) into %g1
mov	0, %o0	! move 0(return address) into %o0
ta	8	! вызов системы

</source>
}}
{{Hider hiding
|title=Пример программы, выдающей сообщение при считывании загрузочного сектора [[дискета|дискеты]] [[IBM PC-совместимый компьютер|IBM PC-совместимого компьютера]]
|content=
<source lang="asm">
org 7C00h
use16

jmp code
nop

db 'hellowrd'
SectSize  dw 00200h
ClustSize db 001h
ResSecs   dw 00001h
FatCnt    db 002h
RootSiz   dw 000E0h
TotSecs   dw 00B40h
Media     db 0F0h
FatSize   dw 00009h
TrkSecs   dw 00012h
HeadCnt   dw 00002h
HidnSec   dw 00000h

code:

cli
mov ax, cs
mov ds, ax
mov ss, ax
mov sp, 7c00h
sti

mov ax,0b800h
mov es,ax

mov di,200
mov ah,2
mov bx,MessStr
msg_print:
mov al,[cs:bx]
mov [es:di],ax
inc bx
add di,2
cmp bx,MessEnd
jnz msg_print

loo:
jmp loo

MessStr equ $
Message db 'Hello, World!'
MessEnd equ $
</source>
}}

== История и терминология ==
Данный тип языков получил своё название от названия [[транслятор]]а ([[компилятор]]а) с этих языков — ассемблера ({{lang-en|assembler}} — сборщик). Название обусловлено тем, что программа «автоматически собиралась», а не вводилась вручную покомандно непосредственно в [[машинный код|кодах]]. При этом наблюдается путаница терминов: ассемблером нередко называют не только транслятор, но и соответствующий язык программирования («программа на ассемблере»).

Использование термина «язык ассемблера» также может вызвать ошибочное мнение о существовании некоего единого языка низкого уровня или хотя бы стандартов на такие языки. При именовании языка ассемблера желательно уточнять, ассемблер для какой [[Архитектура компьютера|архитектуры]] имеется в виду.

== Примечания ==
{{примечания}}

== Литература ==
{{Навигация
 |Тема         = Язык ассемблера
 |Портал       = 
 |Викисловарь  = 
 |Викиучебник  = Ассемблер в Linux для программистов C
 |Викиверситет = 
 |Викицитатник = 
 |Викитека     = 
 |Викивиды     = 
 |Викиновости  = 
 |Викисклад    = 
 |Метавики     = 
 |Проект       = 
}}
* {{книга
|автор = Галисеев Г. В.
|заглавие = Ассемблер для Win 32. Самоучитель
|место = М. |издательство = [[Диалектика (издательство)|Диалектика]]
|год = 2007
|страниц = 368
|isbn = 978-5-8459-1197-1
}}
* {{книга
|автор=Зубков С. В.
|заглавие=Ассемблер для DOS, Windows и UNIX
|место = М. ДМК Пресс; СПб. Питер
|год = 2006
|страниц = 608
|isbn = 5-94074-259-9
}}
* {{книга
|автор = Кип Ирвин.
|заглавие = Язык ассемблера для процессоров Intel
|оригинал = Assembly Language for Intel-Based Computers
|место = М. |издательство = [[Вильямс (издательство)|Вильямс]]
|год = 2005
|страниц = 912
|isbn = 0-13-091013-9
}}
* {{книга
|автор=Калашников О. А.
|заглавие=Ассемблер? Это просто! Учимся программировать
|место=СПб.
|издательство=[[БХВ-Петербург]]
|год=2007
|страниц=384
|isbn=978-5-94157-709-5
}}
* {{книга
|автор=Крис Касперски.
|заглавие=Искусство дизассемблирования
|место=СПб.
|издательство=[[БХВ-Петербург]]
|год=2008
|страниц=896
|isbn=978-5-9775-0082-1
}}
* {{книга
|автор=Владислав Пирогов.
|заглавие=Ассемблер для Windows
|место=СПб.
|издательство=[[БХВ-Петербург]]
|год=2007
|страниц=896
|isbn=978-5-9775-0084-5
}}
* {{книга
|автор=Владислав Пирогов.
|заглавие=Ассемблер и дизассемблирование
|место=СПб.
|издательство=[[БХВ-Петербург]]
|год=2006
|страниц=464
|isbn=5-94157-677-3
}}
* {{книга
|автор=Ричард Саймон.
|заглавие=Microsoft Windows API Справочник системного программиста
}}
* {{книга
|автор=Фрунзе А. В.
|заглавие=Микроконтроллеры? Это же просто! |nodot=1
|том=1
}}
* {{книга
|автор = Юров В., Хорошенко С.
|заглавие = Assembler: учебный курс
|место = СПб.
|издательство = [[Питер (издательство)|Питер]]
|год = 1999
|страницы = 672
|isbn = 5-314-00047-4
}}
* {{книга
|автор = Аблязов Р. З.
|заглавие = Программирование на ассемблере на платформе х86-64
|место = М.
|издательство = [[ДМК Пресс]]
|год = 2011
|страницы = 304
|isbn = 978-5-94074-676-8
}}
* Юричев Д., Введение в reverse engineering для начинающих. http://yurichev.com/writings/RE_for_beginners-ru.pdf

== Ссылки ==
* [http://www.wasm.ru/ WASM.ru] — портал, посвящённый информационной безопасности и программированию на языках ассемблера.
* [http://web.archive.org/web/20120111083233/http://www.wasm.ru/] — Архив статей с сайта «wasm.ru». На самом сайте в данный момент доступен только форум
* [http://www.codegurus.be/codegurus/Programming/assembler&win64_en.htm Assembler & Win64]{{ref-en}} — введение в ассемблер под х86-64

{{Ассемблеры}}
{{Языки программирования}}

[[Категория:Языки программирования по алфавиту|Ассемблер]]
[[Категория:Ассемблер|*]]

[[pl:Asembler#Język asemblera]]