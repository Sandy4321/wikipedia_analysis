{{Карточка языка программирования
|name                    = Java
|logo                    = Java logo and wordmark.svg
|paradigm                = [[объектно-ориентированное программирование|объектно-ориентированный]], [[структурное программирование|структурный]], [[Императивное программирование|императивный]], [[функциональное программирование|функциональный]], [[Платформонезависимость|кроссплатформенный]]
|year                    = 26 августа 1996 года.
|designer                = [[Oracle]] (до 2010 — [[Sun Microsystems]])
|latest_release_version  = Java Standard Edition 8<ref>[http://www.oracle.com/technetwork/java/javase/downloads/index.html Oracle Official Website]</ref>,
|latest_release_date     = 18 марта 2014
|latest_preview_version  = 
|latest_preview_date     = 
|typing = [[строгая типизация|строгая]], [[статическая типизация|статическая]], {{translation|:en:Nominative type system|Именованная типизация|именованная}}, {{translation|:en:Manifest typing|Явная типизация|явная}}
|turing-complete         = Да
|implementations         = [[:Категория:Виртуальные машины Java|многочисленные]]
|dialects                = {{не переведено|есть=:en:Generic Java|надо=Generic Java|текст=Generic Java}}, {{не переведено|есть=:en:Pizza (programming language)|надо=Pizza (язык программирования)|текст=Pizza}}
|influenced_by           = [[Objective-C]]<ref>[http://cs.gmu.edu/~sean/stuff/java-objc.html Java Was Strongly Influenced by Objective-C]</ref>, [[Ада 83]], [[Object Pascal]]<ref>[http://java.sun.com/docs/white/delegates.html White Paper. About Microsoft’s «Delegates»] Официальный сайт</ref>, [[UCSD Pascal]]<ref>[http://www.fscript.org/prof/javapassport.pdf History of Java in Java Application Servers Report] TechMetrix Research, 1999</ref>, [[Оберон (язык программирования)|Oberon]]<ref>Идея динамической кодогенерации взята из диссертации ученика Вирта Микаэля Франца ([http://www.ict.edu.ru/ft/004790/obe_fate.pdf PC World Russia CD, September 2005])</ref><ref name="wirthNN">[http://www.oberon2005.oberoncore.ru/r260905.html Лекция Н. Вирта в Нижегородском государственном университете им. Н. И. Лобачевского]</ref>,[[C++]], [[C Sharp|C#]]<ref>В Java 5.0 было добавлено несколько новых особенностей ([[foreach]], autoboxing, varargs и [[Аннотации в Java|аннотаций]]), после того, как они были введены в аналогичный (и конкурирующий) язык [[C Sharp|C#]]; см.: http://www.barrycornelius.com/papers/java5/ http://www.levenez.com/lang/</ref>, [[Smalltalk]], [[Эйфель (язык программирования)|Eiffel]]<ref>{{cite web|author=Gosling, McGilton.|title=The Java Language Environment|date=май 1996|url=http://java.sun.com/docs/white/langenv/Intro.doc1.html#943|publisher=Официальный сайт|accessdate=???|archiveurl=http://www.webcitation.org/6170iD8ff|archivedate=2011-08-22}}</ref>, {{не переведено|есть=:en:Mesa (programming language)|надо=Mesa (язык программирования)|текст=Mesa}}<ref>{{cite web|author=J. Gosling, B. Joy, G. Steele, G. Brachda.|title=The Java Language Specification, 2nd Edition|url=http://java.sun.com/docs/books/jls/second_edition/html/intro.doc.html#237601|publisher=Официальный сайт|accessdate=???|archiveurl=http://www.webcitation.org/6170inw46|archivedate=2011-08-22}}</ref>, [[Modula-3]]<ref>[http://www.computerworld.com.au/index.php/id;1422447371;pp;3;fp;4194304;fpid;1 The A-Z of Programming Languages: Modula-3 — a-z of programming languages — Computerworld]</ref>, {{не переведено|есть=:en:Generic Java|надо=Generic Java|текст=Generic Java}}
|influenced              = [[Ада 2005]], [[C Sharp|C#]], [[Clojure]], [[D (язык программирования)|D]], [[ECMAScript]], [[Groovy]], [[J Sharp|J#]], [[Visual J Sharp|VJ#]], [[JavaScript]], [[PHP]], [[Scala (язык программирования)|Scala]], [[Python]], [[BeanShell]], [[Kotlin]], [[Gentee]]
|operating_system        = [[Кроссплатформенное программное обеспечение|кроссплатформенный]]
|license                 = [[GNU General Public License]] / [[Java Community Process]]
|website                 = http://java.com
|Умерла = 2015 июль}}
{{О|языке программирования|платформе для создания приложений на основе данного языка|Java (программная платформа)}}
{{не путать|JavaScript}}

'''Java'''<ref>Произносится на английском как {{IPA|/ˈdʒɑːvə/}}, в русском языке встречаются транслитерации «Джава» и «Ява», правообладатели торговой марки предпочитают первую транслитерацию.</ref> — [[объектно-ориентированный язык программирования]], разработанный компанией [[Sun Microsystems]] (в последующем приобретённой компанией [[Oracle]]). Приложения Java обычно [[транслятор|транслируются]] в специальный [[байт-код]], поэтому они могут работать на любой [[Java Virtual Machine|виртуальной Java-машине]]  вне зависимости от [[компьютерная архитектура|компьютерной архитектуры]]. Дата официального выпуска — 23 мая 1995 года.

== Название ==
Изначально язык назывался Oak («Дуб») разрабатывался [[Гослинг, Джеймс|Джеймсом Гослингом]] для программирования бытовых электронных устройств. Впоследствии он был переименован в Java и стал использоваться для написания клиентских приложений и [[Сервер (программное обеспечение)|серверного]] программного обеспечения. Назван в честь марки [[кофе]] Java, которая, в свою очередь, получила наименование одноимённого острова ([[Ява]]), поэтому на официальной эмблеме языка изображена чашка с дымящимся кофе. Существует и другая версия происхождения названия языка, связанная с [[Аллюзия|аллюзией]] на кофе-машину как пример бытового устройства, для программирования которого изначально язык создавался.

== Основные особенности языка ==
Программы на Java [[транслятор|транслируются]] в [[байт-код]], выполняемый [[Java Virtual Machine|виртуальной машиной Java]] (JVM) — программой, обрабатывающей байтовый код и передающей инструкции оборудованию как [[интерпретатор]].

[[Файл:Wave.svg|thumb|150px|Дюк, талисман Java]]

Достоинством подобного способа выполнения программ является полная независимость байт-кода от [[Операционная система|операционной системы]] и [[аппаратная платформа|оборудования]], что позволяет выполнять Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Другой важной особенностью технологии Java является гибкая система безопасности, в рамках которой исполнение программы полностью контролируется виртуальной машиной. Любые операции, которые превышают установленные полномочия программы (например, попытка несанкционированного доступа к данным или соединения с другим компьютером), вызывают немедленное прерывание.

Часто к недостаткам концепции виртуальной машины относят снижение производительности. Ряд усовершенствований несколько увеличил скорость выполнения программ на Java:
* применение технологии трансляции байт-кода в машинный код непосредственно во время работы программы ([[JIT]]-технология) с возможностью сохранения версий класса в машинном коде,
* широкое использование [[платформенно-ориентированный код|платформенно-ориентированного кода]] (native-код) в стандартных библиотеках,
* аппаратные средства, обеспечивающие ускоренную обработку байт-кода (например, технология [[Jazelle]], поддерживаемая некоторыми процессорами фирмы [[ARM (компания)|ARM]]).

По данным сайта shootout.alioth.debian.org, для семи разных задач время выполнения на Java составляет в среднем в полтора-два раза больше, чем для C/C++, в некоторых случаях Java быстрее, а в отдельных случаях в 7 раз медленнее<ref name="slow_java">[http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=java Java 6 -server speed ÷ C++ GNU g++ speed | Computer Language Benchmarks Game]</ref>. С другой стороны, для большинства из них потребление памяти Java-машиной было в 10—30 раз больше, чем программой на C/C++. Также примечательно исследование, проведённое компанией [[Google (компания)|Google]], согласно которому отмечается существенно более низкая производительность и бо́льшее потребление памяти в тестовых примерах на Java в сравнении с аналогичными программами на [[C++]]<ref>{{cite web
 | url         = http://www.theregister.co.uk/2011/06/03/google_paper_on_cplusplus_java_scala_go/
 | title       = Google pits C++ against Java, Scala, and Go
 | author      = Metz, Cade
 | date        = 2011-06-03
 | work        = 
 | publisher   = [[The Register]]
 | accessdate  = 2011-06-05
 | lang        = en
 | archiveurl  = http://www.webcitation.org/6170nFPxZ
 | archivedate = 2011-08-22
}}</ref><ref>[https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf Loop Recognition in C++/Java/Go/Scala]{{ref-pdf|0.3}}</ref><ref>[http://www.opennet.ru/opennews/art.shtml?num=30784 В Google провели сравнение производительности C++, Java, Go и Scala]</ref>.

Идеи, заложенные в концепцию и различные реализации среды виртуальной машины Java, вдохновили множество энтузиастов на расширение перечня языков, которые могли бы быть использованы для создания программ, исполняемых на виртуальной машине<ref>{{cite web
 | author      = Robert Tolksdorf.
 | url         = http://www.is-research.de/info/vmlanguages/
 | title       = Programming languages for the Java Virtual Machine JVM
 | publisher   = is-research GmbH
 | accessdate  = 5 июня 2009
 | lang        = en
 | description = Онлайн-каталог альтернативных языков и языковых расширений для JVM
 | archiveurl  = http://www.webcitation.org/6170nqDc9
 | archivedate = 2011-08-22
}}</ref>. Эти идеи нашли также выражение в спецификации общеязыковой инфраструктуры [[Common Language Infrastructure|CLI]], заложенной в основу платформы [[.NET Framework|.NET]] компанией [[Microsoft]].

== История версий ==

{{Main|История версий Java}}

=== Java 1.0 ===
Разработка Java началась в 1990 году, первая официальная версия — Java 1.0, — была выпущена только 26 августа 1996 года.

=== Java 1.2 ===
К 1998 году была разработана обновлённая спецификация JDK 1.2, вышедшая под наименованием Java 2. Язык практически не изменился — было добавлено одно [[Зарезервированное слово|ключевое слово]] strictfp. Платформа получила следующие дополнения:
* [[Библиотека (программирование)|Библиотека]] [[Swing]] для создания [[Графический интерфейс пользователя|графического интерфейса пользователя]].
* Коллекции (JSR 166).
* Поддержка файлов Policy и цифровых сертификатов пользователя.
* Библиотека Accessibility.
* Java 2D.
* Поддержка технологии [[drag-and-drop]].
* Полная поддержка [[Unicode]], включая поддержку ввода на японском, китайском и корейском языках.
* Поддержка воспроизведения аудиофайлов нескольких популярных форматов.
* Полная поддержка технологии [[CORBA]].
* JIT-компилятор, улучшенная производительность.
* Усовершенствования инструментальных средств JDK, в том числе поддержка профилирования Java-программ.

=== Java 2 ===
В данном случае встречается путаница. Выпускались книги, например, Beginning Java 2 by Ivor Horton (Mar 1999), фактически по JDK 1.2 (бывшее название — Java 2). Вместе с тем по сей день такие книги публикуются, например: Х. М. Дейтел, П. Дж. Дейтел, С. И. Сантри. Технологии программирования на Java 2. Распределённые приложения (2011).

В то время, когда, как известно, Java 2 была исторически заменена следующими релизами, подобные названия книг дезориентируют в понимании, о какой же версии Java они написаны на самом деле. Если JDK 1.2 принято считать за Java 2, а авторы книг за Java 2 принимают JDK 7, это приводит к полной путанице.

=== Java 5.0 ===
Спецификация Java 5.0 была выпущена в сентябре 2004 года. C этой версии изменена официальная индексация, вместо Java 1.5 правильнее называть Java 5.0. Внутренняя же индексация Sun осталась прежней — 1.x. Минорные изменения теперь включаются без изменения индексации, для этого используется слово «Update» или буква «u», например, Java Development Kit 5.0 Update 22. Предполагается, что в обновления могут входить как исправления ошибок, так и небольшие добавления в API, JVM.

В данной версии разработчики внесли в язык целый ряд принципиальных дополнений:
* [[Перечислимый тип|Перечислимые типы]] ({{lang-en|enum}}). Ранее отсутствовавшие в Java типы оформлены по аналогии с [[C++]], но при этом имеют ряд дополнительных возможностей.
** Перечислимый тип является полноценным классом Java, то есть может иметь конструктор, поля, методы, в том числе скрытые и абстрактные.
** Перечисление может реализовывать [[Интерфейс (объектно-ориентированное программирование)|интерфейсы]].
** Для перечислений имеются встроенные методы, дающие возможность получения значений типа по имени, символьных значений, соответствующих именам, преобразования между номером и значением, проверки типа на то, что он является перечислимым.
* [[Аннотация (Java)|Аннотации]] — возможность добавления в текст программы метаданных, не влияющих на выполнение кода, но допускающих использование для получения различных сведений о коде и его исполнении. Одновременно выпущен инструментарий для использования аннотированного кода. Одно из применений аннотаций — упрощение создания тестовых модулей для Java-кода.
* Средства [[Обобщённое программирование|обобщённого программирования]] ({{lang-en|generics}}) — механизм, аналогичный [[Eiffel]] (позже также появились и в C#, принципиально отличаются от шаблонов C++), дающий возможность создавать классы и методы с полями и параметрами произвольного объектного типа. С использованием данного механизма реализованы новые версии коллекций стандартной библиотеки Java.
* Методы с неопределённым числом параметров.
* Autoboxing/Unboxing — автоматическое преобразование между скалярными типами Java и соответствующими типами-обёртками (например, между int — Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.
* Разрешён импорт статических полей и методов.
* В язык введён цикл по коллекции объектов (итератор, {{lang-en|foreach}}).
* Было введено использование [[Javadoc]]-комментариев, которые используются для автоматического оформления документации по комментариям в исходном коде.

=== Java 6 ===
Релиз версии состоялся 11 декабря 2006 года. Изменена официальная индексация — вместо ожидаемой 6.0 версия значится как 6. Минорные изменения, как и в Java 5.0, вносятся в обычные обновления версии, например, Java Standard Edition Development Kit 6 Update 27. Внесены следующие изменения:

* Коллекции — добавлены интерфейсы для организации очереди, работающей с двух сторон коллекции; организовывающие поиск по ближайшему соответствию; блокирующие себя во время ожидания элемента. Организованы новые классы, реализующие перечисленные интерфейсы.
* Добавлена поддержка японского императорского календаря (наряду с уже существующими григорианским и буддийским календарями).
* Доступны классы-потоки для чтения и передачи сжатых данных, с возможностью передачи их по сети. Сняты ограничения на количество файлов в архиве (ранее 64 Кб), длину названия файла (ранее 256 символов) и количество одновременно открытых файлов (ранее 2000 шт).
* Организована система управления кэшем и добавлена поддержка параметра «no-cache» в HTTP-запросе.
* JConsole, графический мониторинг JVM, стала официально поддерживаемой утилитой.
* Java HTTP Server, позволяет создать полноценный HTTP сервер, с минимально необходимыми функциональными свойствами.
* Повысилась скорость вычислений на 70 %, скорость операций ввода-вывода возросла в два раза<ref>[http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.3 Результаты тестов]</ref>.
* Swing — улучшена работоспособность OpenGL и DirectX; обработка текста на LCD; добавлен GifWriter, для работы с файлами .gif.
* Исправлено большое количество ошибок.

=== Java 7 ===
Релиз версии состоялся 28 июля 2011 года<ref>[http://openjdk.java.net/projects/jdk7/ план разработки для JDK7]</ref>. В финальную версию Java Standard Edition 7 не были включены все ранее запланированные изменения. Согласно плану развития (план «Б»)<ref>[http://mreinhold.org/blog/plan-b План Б]</ref>, включение нововведений будет разбито на две части: Java Standard Edition 7 (без [[Лямбда-исчисление|лямбда-исчисления]], проекта Jigsaw, и части улучшений [[:en:COIN-OR|Coin]]) и Java Standard Edition 8 (все остальное), намеченный на конец 2012 года.

В новой версии, получившей название Java Standard Edition 7 (Java Platform, Standard Edition 7), помимо исправления большого количества ошибок, было представлено несколько новшеств. Так, например, в качестве эталонной реализации Java Standard Edition 7 использован не проприетарный пакет [[JDK]], а его открытая реализация [[OpenJDK]], а сам релиз новой версии платформы готовился при тесном сотрудничестве инженеров [[Oracle]] с участниками мировой экосистемы Java, комитетом [[JCP]] (Java Community Process) и сообществом OpenJDK. Все поставляемые Oracle бинарные файлы эталонной реализации Java Standard Edition 7 собраны на основе кодовой базы OpenJDK, сама эталонная реализация полностью открыта под лицензией [[GPLv2]] с исключениями [[GNU]] ClassPath, разрешающими динамическое связывание с проприетарными продуктами. К другим нововведениям относится интеграция набора небольших языковых улучшений Java, развиваемых в рамках проекта Coin, добавлена поддержка языков программирования с динамической типизацией, таких, как [[Ruby]], [[Python]] и [[JavaScript]], поддержка загрузки классов по [[URL]], обновлённый [[XML]]-стек, включающий [[JAXP]] 1.4, [[JAXB]] 2.2a и [[JAX-WS]] 2.2 и другие<ref>[http://citforum.ru/news/26682/ Компания Oracle анонсировала выход Java Standard Edition 7] {{ref-ru}}</ref>.

За 5 дней до выхода релиза Java Standard Edition 7 было обнаружено несколько серьёзных ошибок в горячей оптимизации циклов, которая включена по умолчанию и приводит виртуальную машину Java к краху. Специалисты Oracle найденные ошибки за столь короткий срок исправить не могли, но пообещали, что они будут исправлены во втором обновлении (Java 7 Update 2) и частично в первом<ref>[http://www.lucidimagination.com/search/document/1a0d3986e48a9348/warning_index_corruption_and_crashes_in_apache_lucene_core_apache_solr_with_java_7 Index corruption and crashes in Apache Lucene Core / Apache Solr with Java 7] {{ref-en}}</ref>.

==== Список нововведений ====
* Поддержка динамически-типизированных языков (InvokeDynamic) — расширение JVM (семантики байт-кода), языка Java<ref>[http://ntv.ifmo.ru/ru/article/515/aktornoe_rasshirenie_yazyka_JAVA_v_srede_MPS.htm Акторное расширение языка Java в среде MPS]. - вестник ИТМО. - Вып 6 (94)</ref> для поддержки динамически-типизированных языков.
* Строгая проверка class-файлов — class-файлы версии 51 (Java Standard Edition 7) или более поздней версии должны быть проверены typechecking-верификатором; JVM не должна переключаться на старый верификатор.
* Изменение синтаксиса языка Java (Project Coin) — частичные изменения в языке Java, предназначенные для упрощения общих задач программирования:
** Использование класса String в блоке switch.
** Закрытие используемых ресурсов в блоке try (try-with-resources) — работает при использовании интерфейса AutoCloseable.
** Объединённая обработка исключений в блоке catch (multi-catch exceptions) — перечисление обрабатываемых исключений в catch (… | … | …).
** Повторное выбрасывание исключений (rethrowing exceptions) — передача возникшего исключения «вверх» по [[Стек вызовов|стеку вызовов]].
** Подчёркивания в числовых литералах для лучшего восприятия больших чисел.
** Изменение вывода типа в Java generic при создании объекта.
** Использование двоичных чисел (binary literals) — [[Префикс (информатика)|префикс]] «0b» укажет, что используется двоичное число.
** Упрощение вызова методов varargs — уменьшение предупреждений при вызове метода с переменным числом входящих переменных.

* Модификация загрузчика классов (class-loader) — избежание тупиковых ситуаций в неиерархической топологии загрузки классов.
* Закрытие ресурсов, открытых URLClassLoader.
* Обновление коллекций (JSR 166).
* Поддержка Unicode 6.0.
* Отделение языка пользователя и языка пользовательского интерфейса — обновление обработки языков для отделения локали от языка пользовательского интерфейса.
* Новые интерфейсы I/O для платформы Java (nio.2).
* Использование JDBC 4.1 и Rowset 1.1.
* … (не закончено)

=== Java 8 ===
Релиз версии состоялся 19 марта 2014 года.
==== Список нововведений ====

* Полноценная поддержка лямбда-выражений.
* Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию.
* Ссылки на методы.
* Функциональные интерфейсы (предикаты, поставщики и т. д.)
* Потоки (stream) для работы с коллекциями
* Новое API для работы с датами
* … (не закончено)

=== Java 9 ===

==== Список нововведений ====

* Интеграция jigsaw.
* … (не закончено)

== Классификация платформ Java ==

Внутри Java существуют несколько основных семейств технологий:
* [[Java SE]] — Java Standard Edition, основное издание Java, содержит компиляторы, API, [[Java Runtime Environment]]; подходит для создания пользовательских приложений, в первую очередь — для настольных систем.
* [[Java EE]] — Java Enterprise Edition, представляет собой набор спецификаций для создания программного обеспечения уровня предприятия.
* [[Java ME]] — Java Micro Edition, создана для использования в устройствах, ограниченных по вычислительной мощности, например, в [[мобильный телефон|мобильных телефонах]], [[Карманный персональный компьютер|КПК]], встроенных системах;
* [[JavaFX]] — технология, являющаяся следующим шагом в эволюции Java как Rich Client Platform; предназначена для создания графических интерфейсов корпоративных приложений и бизнеса.
* [[Java Card]] — технология предоставляет безопасную среду для приложений, работающих на смарт-картах и других устройствах с очень ограниченным объёмом памяти и возможностями обработки.

== Java и Microsoft ==
Компанией [[Microsoft]] была разработана собственная реализация [[JVM]] (MSJVM<ref name=msjvm />), включавшаяся в состав различных [[Операционная система|операционных систем]], начиная с [[Windows 98]] (также входила в Internet Explorer от версии 3 и выше, что позволяло использовать MSJVM (Microsoft java virtual machine)  в ОС Windows 95 и Windows NT 4 после установки IE3+ на данные ОС).

MSJVM имела существенные отличия от Sun Java, во многом ломающие основополагающую концепцию переносимости программ между разными платформами:
* отсутствие поддержки [[Интерфейс программирования приложений|программного интерфейса]] [[Remote Procedure Call|вызова удаленных методов]] ([[RMI]]);
* отсутствие поддержки технологии [[JNI]];
* наличие нестандартных расширений, таких, как средства интеграции Java и [[DCOM]], работающих только на платформе Windows.

Тесная интеграция Java с DCOM и Win32 поставила под вопрос кроссплатформенную парадигму языка. Впоследствии это явилось поводом для судебных исков со стороны Sun Microsystems к Microsoft. Суд принял сторону компании Sun Microsystems. В конечном счёте между двумя компаниями была достигнута договорённость о возможности продления срока официальной поддержки пользователей нестандартной Microsoft JVM до конца 2007 года<ref name=msjvm>{{cite web
 | date        = 12 сентября 2003
 | url         = http://www.microsoft.com/About/Legal/EN/US/Interoperability/Java/Default.aspx
 | title       = Microsoft Java Virtual Machine Support
 | publisher   = Microsoft
 | accessdate  = 9 октября 2010
 | lang        = en
 | description = Официальное заявление Microsoft о программе поддержки MSJVM
 | archiveurl  = http://www.webcitation.org/6170oubDn
 | archivedate = 2011-08-22
}}</ref>.

В 2005 году компанией Microsoft для платформы [[.NET Framework|.NET]] был представлен Java-подобный язык [[Visual J Sharp|J#]], не соответствующий официальной спецификации языка Java и исключённый впоследствии из стандартного инструментария разработчика [[Microsoft Visual Studio]], начиная с Visual Studio 2008<ref>{{cite web
 | date        = ноябрь 2007
 | url         = http://msdn.microsoft.com/ru-ru/library/7xsxf8e2%28VS.90%29.aspx
 | title       = Visual J#
 | publisher   = Microsoft
 | accessdate  = 10 октября 2010
 | lang        = ru
 | description = Официальная информация Microsoft об исключении J# из комплекта Visual Studio 2008
 | archiveurl  = http://www.webcitation.org/6170pJXt3
 | archivedate = 2011-08-22
}}</ref>.

== Java и Android ==

{{Main|Android}}

Язык Java активно используется для создания мобильных приложений под операционную систему Android. При этом программы компилируются в нестандартный байт-код, для использования их виртуальной машиной [[Dalvik virtual machine|Dalvik]]. Для такой компиляции используется дополнительный инструмент, а именно [[SDK|Software Development Kit]], разработанный компанией [[Google]].

Разработку приложений можно вести в среде Android Studio, [[NetBeans]], в среде [[Eclipse (среда разработки)|Eclipse]], используя при этом плагин Android Development Tools (ADT) или в [[IntelliJ IDEA]]. Версия JDK при этом должна быть 5.0 или выше.

8 декабря 2014 года [[Android Studio]] признана компанией [[Google]] официальной средой разработки под ОС Android.

== Применения платформы Java ==

Следующие успешные проекты реализованы с привлечением Java ([[J2EE]]) технологий: [[RuneScape]], [[Amazon]]<ref>{{cite web
 | author        = Todd Hoff.
 | date = 18 сентября 2007
 | url           = http://highscalability.com/amazon-architecture
 | title         = Amazon Architecture
 | accessdate    = 6 июня 2009
 | lang          = en
 | description   = Обсуждение архитектуры Amazon с использованием Java-технологий
}}</ref><ref>{{cite web
 | url         = http://aws.amazon.com/ec2/
 | title       = Amazon Elastic Compute Cloud (Amazon EC2)
 | publisher   = Amazon Web Services LLC
 | accessdate  = 6 июня 2009
 | lang        = en
 | description = Описание технологии и возможностей Amazon EC2 как веб-сервиса
 | archiveurl  = http://www.webcitation.org/6170rMoFx
 | archivedate = 2011-08-22
}}</ref>, [[eBay]]<ref>{{cite web
 | author      = Todd Hoff.
 | date        = 27 мая 2008
 | url         = http://highscalability.com/ebay-architecture
 | title       = eBay Architecture
 | accessdate  = 6 сентября 2009
 | lang        = en
 | description = Обсуждение архитектуры eBay на платформе Java
 | archiveurl  = http://www.webcitation.org/6170rzVA7
 | archivedate = 2011-08-22
}}</ref><ref>{{cite web
 | author      = Randy Shoup, Dan Pritchett.
 | date        = 29 ноября 2006
 | url         = http://www.addsimplicity.com/downloads/eBaySDForum2006-11-29.pdf
 | title       = The eBay Architecture
 | work        = SD Forum 2006
 | publisher   = ???
 | accessdate  = 6 июня 2009
 | lang        = en
 | description = Презентация по истории развития архитектуры eBay
 | archiveurl  = http://www.webcitation.org/6170saktV
 | archivedate = 2011-08-22
}}</ref>, [[LinkedIn]]<ref>{{cite web
 | author      = Brian Guan.
 | date        = 11 июня 2008
 | url         = http://blog.linkedin.com/2008/06/11/grails-at-linkedin/
 | title       = The LinkedIn Blog. Blog Archive. Grails at LinkedIn
 | publisher   = LinkedIn.com
 | accessdate  = 5 июня 2009
 | lang        = en
 | description = История создания системы LinkedIn на основе Java-технологии Grails
 | archiveurl  = http://www.webcitation.org/6170ueU7e
 | archivedate = 2011-08-22
}}</ref>, [[Yahoo!]]<ref>{{cite web
 | url         = http://developer.yahoo.com/hadoop/
 | title       = Hadoop and Distributed Computing at Yahoo!
 | publisher   = Yahoo!
 | accessdate  = 21 июня 2009
 | lang        = en
 | description = Стартовая страница Java-технологии распределённого обслуживания Hadoop на портале разработчиков Yahoo!
 | archiveurl  = http://www.webcitation.org/6170vguJb
 | archivedate = 2011-08-22
}}</ref>.

Следующие компании в основном фокусируются на Java ([[J2EE]]) технологиях: [[SAP]], [[IBM]], [[Oracle]]. В частности, [[Система управления базами данных|СУБД]] [[Oracle Database]] включает JVM как свою составную часть, обеспечивающую возможность непосредственного программирования СУБД на языке Java, включая, например, [[хранимая процедура|хранимые процедуры]]<ref>{{cite web
 | url         = http://www.oracle.com/technology/tech/java/jsp/index.html
 | title       = OracleJVM and Java Stored Procedures
 | publisher   = Oracle Inc.
 | accessdate  = 5 июня 2009
 | lang        = en
 | description = Раздел портала Oracle, посвящённый технологиям Java в составе сервера СУБД Oracle
 | archiveurl  = http://www.webcitation.org/6170wCzk5
 | archivedate = 2011-08-22
}}</ref>.

=== Производительность ===

Программы, написанные на Java, имеют репутацию более медленных и занимающих больше оперативной памяти, чем написанные на языке C<ref name="slow_java"/>. Тем не менее, скорость выполнения программ, написанных на языке Java, была существенно улучшена с выпуском в 1997—1998 годах так называемого JIT-компилятора в версии 1.1 в дополнение к другим особенностям языка для поддержки лучшего анализа кода (такие, как внутренние классы, класс StringBuffer, упрощенные логические вычисления и т. д.). Кроме того, была произведена оптимизация виртуальной машины Java — с 2000 года для этого используется виртуальная машина [[HotSpot]]. По состоянию на февраль 2012 года, код Java 7 приблизительно лишь в 1.8 раза медленнее кода, написанного на языке Си<ref>{{cite web
 | url         = http://shootout.alioth.debian.org/u32q/which-programming-languages-are-fastest.php?gcc=on&javasteady=on&java=on&csharp=on&javaxint=on&calc=chart
 | title       = Ubuntu: Intel® Q6600® quad-core Computer Language Benchmarks
 | archiveurl  = http://www.webcitation.org/68bfPITT0
 | archivedate = 2012-06-22
}}</ref>.

Некоторые платформы предлагают аппаратную поддержку выполнения для Java{{нет АИ|10|10|2011}}. К примеру, микроконтроллеры, выполняющие код Java на аппаратном обеспечении вместо программной JVM, а также основанные на ARM процессоры, которые поддерживают выполнение байткода Java через опцию Jazelle.

== Основные возможности ==
* [[Сборка мусора (программирование)|автоматическое управление памятью]];
* расширенные возможности обработки исключительных ситуаций;
* богатый набор средств фильтрации ввода-вывода;
* набор стандартных коллекций: [[Индексный массив|массив]], [[Список (информатика)|список]], [[стек]] и т. п.;
* наличие простых средств создания сетевых приложений (в том числе с использованием [[Сетевой протокол|протокола]] [[RMI]]);
* наличие классов, позволяющих выполнять [[HTTP]]-запросы и обрабатывать ответы;
* встроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки (например, python);
* унифицированный доступ к [[База данных|базам данных]]:
:* на уровне отдельных [[SQL]]-запросов — на основе [[JDBC]], [[SQLJ]];
:* на уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе {{translation|:en:Java Data Objects|Java Data Objects}} и [[Java Persistence API]];
* поддержка обобщений (начиная с версии 1.5);
* поддержка лямбд, замыканий, встроенные возможности функционального программирования (с 1.8);
* параллельное выполнение программ {{Что}}.

== Пространство имён ==
{{main|Пространство имён (программирование)}}
Идея пространств имён воплощена в [[Package (Java)|Java-пакетах]].

Внутри пакета есть два независимых пространства имен: переменные и методы.

== Пример программы ==
[[обобщённое программирование|Generics]]:
{{Hider hiding
|title=Пример использования <code>Generics</code> 
|content=
<source lang="java">
import java.util.*;
public class Sample {
    public static void main(String[] args) {
        // Создание объекта по шаблону.
        List<String> strings = new LinkedList<String>();
        strings.add("Hello");
        strings.add("world");
        strings.add("!");
        for (String s : strings) {
            System.out.print(s + " ");
        }
    }
}
</source>
}}

[[Отражение (программирование)|Reflection]]:
{{Hider hiding
|title=Пример использования <code>Reflection</code> 
|content=
<source lang="java">

import java.lang.reflect.Field;
import java.lang.reflect.Method;

class TestClass {
    private int value;
    public int getValue() { return value; }
    public void setValue(int valueIn) { this.value = valueIn; }
}

public class Main {

    public static void main(String[] args) {
        TestClass testClass = new TestClass();

        for (Field field: testClass.getClass().getDeclaredFields()) {
            System.out.printf("name: %s, type: %s \n", field.getName(), field.getType().getCanonicalName());
        }

        for (Method method : testClass.getClass().getDeclaredMethods()) {
            System.out.printf("name: %s, return type: %s  \n", method.getName(), method.getReturnType().getCanonicalName());
        }        
    }
}
</source>
}}

[[Аннотация (Java)|Аннотаций]]:
{{Hider hiding
|title=Пример использования <code>Аннотаций</code> 
|content=
<source lang="java">

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Annotation {

    public boolean value() default false;

}

@Annotation(value=true)
public class TestClass {

}

public class Main {

    public static void main(String[] args) {
        TestClass testClass = new TestClass();

        Annotation annotation = testClass.getClass().getAnnotation(Annotation.class);
        if (annotation != null) {
            System.out.printf("value: %s \n", annotation.value());
        }
    }
}

</source>
}}

== Основные идеи ==

=== Примитивные типы ===
В языке Java только 8 примитивных (скалярных, простых) [[Тип данных|типов]]: [[Логический тип|boolean]], [[Байт|byte]], [[символьный тип|char]], [[short]], [[целый тип|int]], [[Long (тип данных)|long]], [[число одинарной точности|float]], [[double]]. Существует также вспомогательный девятый примитивный тип — [[void]], однако переменные и поля такого типа не могут быть объявлены в коде, а сам тип используется только для описания соответствующего ему класса, для использования при [[Отражение (программирование)|рефлексии]]. Кроме того, с помощью класса {{Javadoc:SE|java/lang|Void}} можно узнать, является ли определённый метод типа <code>void</code>: <code>Hello.class.getMethod("main", Array.newInstance(String.class, 0).getClass()).getReturnType() == Void.TYPE</code>.

Длины и диапазоны значений примитивных типов определяются стандартом, а не реализацией, и приведены в таблице. Тип char сделали двухбайтовым для удобства локализации (один из идеологических принципов Java): когда складывался стандарт, уже существовал [[Unicode]]-16, но не Unicode-32. Поскольку в результате не осталось однобайтового типа, добавили новый тип byte, причём в Java, в отличие от других языков, он не является беззнаковым. Типы float и double могут иметь специальные значения <math>+\infty</math>, <math>-\infty</math> и «не число» ([[NaN]]). Для типа double они обозначаются <code>Double.POSITIVE_INFINITY</code>, <code>Double.NEGATIVE_INFINITY</code>, <code>Double.NaN</code>; для типа float — так же, но с приставкой Float вместо Double. Минимальные и максимальные значения, принимаемые типами float и double, тоже стандартизованы.

{| class="wikitable"
! Тип
! Длина (в байтах) || Диапазон или набор значений
|-
| boolean || 1 в массивах, 4 в переменных<ref>JVM не имеет поддержки для переменных типа boolean, поэтому они представляются в виде значений типа int. Однако массивы boolean[] поддерживаются. [http://java.sun.com/docs/books/jvms/second_edition/html/Overview.doc.html#22909 VM Spec The Structure of the Java Virtual Machine]</ref>|| true, false
|-
| byte || 1 || −128..127
|-
| char || 2 || 0..2<sup>16</sup>−1, или 0..65535
|-
| short || 2 || −2<sup>15</sup>..2<sup>15</sup>−1, или −32768..32767
|-
| int || 4 || −2<sup>31</sup>..2<sup>31</sup>−1, или −2147483648..2147483647
|-
| long || 8 || −2<sup>63</sup>..2<sup>63</sup>−1, или примерно −9.2·10<sup>18</sup>..9.2·10<sup>18</sup>
|-
|-
| float || 4 || -(2-2<sup>−23</sup>)·2<sup>127</sup>..(2-2<sup>−23</sup>)·2<sup>127</sup>, или примерно −3.4·10<sup>38</sup>..3.4·10<sup>38</sup>, а также <math>-\infty</math>, <math>\infty</math>, NaN
|-
| double || 8 || -(2-2<sup>−52</sup>)·2<sup>1023</sup>..(2-2<sup>−52</sup>)·2<sup>1023</sup>, или примерно −1.8·10<sup>308</sup>..1.8·10<sup>308</sup>, а также <math>-\infty</math>, <math>\infty</math>, NaN
|}

Такая жёсткая стандартизация была необходима, чтобы сделать язык платформенно-независимым, что является одним из идеологических требований к Java. Тем не менее, одна небольшая проблема с платформенной независимостью всё же осталась. Некоторые процессоры используют для промежуточного хранения результатов 10-байтовые [[Регистр процессора|регистры]] или другими способами улучшают точность вычислений. Для того, чтобы сделать Java максимально совместимой между разными системами, в ранних версиях любые способы повышения точности вычислений были запрещены. Однако это приводило к снижению быстродействия. Выяснилось, что ухудшение точности ради платформенной независимости мало кому нужно, тем более если за это приходится платить замедлением работы программ. После многочисленных протестов этот запрет отменили, но добавили ключевое слово <code>strictfp</code>, запрещающее повышение точности.

==== Преобразования при математических операциях ====
В языке Java действуют следующие правила:
# Если один [[операнд]] имеет тип double, другой тоже преобразуется к типу double.
# Иначе, если один операнд имеет тип float, другой тоже преобразуется к типу float.
# Иначе, если один операнд имеет тип long, другой тоже преобразуется к типу long.
# Иначе оба операнда преобразуются к типу int.

Данный способ неявного преобразования встроенных типов полностью совпадает с преобразованием типов в [[C++]]<ref>{{книга|автор=[[Бьярн Страуструп]].|заглавие=Язык программирования С++|оригинал=The C++ Programming Language|место=М.—СПб.|издательство= Бином, Невский диалект|год=2008||страниц=1104|isbn=5-7989-0226-2; ISBN 5-7940-0064-3; ISBN 0-201-70073-5|тираж=5000}}</ref>.

=== Объектные переменные, объекты, ссылки и указатели ===
В языке Java имеются только динамически создаваемые объекты. Причём [[Переменная (программирование)|переменные]] объектного типа и объекты в Java — совершенно разные сущности. Переменные объектного типа являются [[Ссылка (программирование)|ссылками]], то есть неявными [[Указатель (тип данных)|указателями]] на динамически создаваемые объекты. Это подчёркивается [[Синтаксис (программирование)|синтаксисом]] описания переменных. Так, в Java нельзя писать:
<source lang="java">
double a[10][20];
Foo b(30);
</source>
а нужно:
<source lang="java">
double[][] a = new double[10][20];
Foo b = new Foo(30);
</source>
При присваиваниях, передаче в [[Подпрограмма|подпрограммы]] и сравнениях объектные переменные ведут себя как указатели, то есть присваиваются, копируются и сравниваются [[Адрес памяти|адреса]] объектов. А при доступе с помощью объектной переменной к полям данных или методам объекта не требуется никаких специальных операций [[Разыменование|разыменовывания]] — этот доступ осуществляется так, как если бы объектная переменная была самим объектом.

Объектными являются переменные любого типа, кроме примитивного. Явных указателей в Java нет. В отличие от указателей C, C++ и других языков программирования, ссылки в Java в высокой степени безопасны благодаря жёстким ограничениям на их использование, в частности:
* Нельзя преобразовывать объект типа <code>int</code> или любого другого примитивного типа в указатель или ссылку и наоборот.
* Над ссылками запрещено выполнять операции ++, −−, +, − или любые другие арифметические операции.
* Преобразование типов между ссылками жёстко регламентировано. За исключением ссылок на массивы, разрешено преобразовывать ссылки только между наследуемым типом и его наследником, причём преобразование наследуемого типа в наследующий должно быть явно задано и во время выполнения производится проверка его осмысленности. Преобразования ссылок на массивы разрешены лишь тогда, когда разрешены преобразования их базовых типов, а также нет конфликтов размерности.
* В Java нет операций взятия адреса (&) или взятия объекта по адресу (*). [[Амперсанд#Прочие применения|Амперсанд]] (&) означает всего лишь «побитовое и» (двойной амперсанд — «логическое и»). Однако для булевых типов одиночный амперсанд означает «логическое и», отличающееся от двойного тем, что цепь проверок не прекращается при получении в выражении значения <code>false</code><ref>Java Language Specification Third Edition — http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2</ref> (напр. <code>a == b && foo() == bar()</code> не повлечёт вызовов <code>foo()</code> и <code>bar()</code> в случае, если <code>a != b</code>, тогда как использование <code>&</code> повлечёт в любом случае.

Благодаря таким специально введенным ограничениям в Java невозможно прямое манипулирование памятью на уровне физических адресов (хотя определено значение ссылки, не указывающей ни на что: <code>null</code>).

Если нужен указатель на примитивный тип, используются классы-обёртки примитивных типов: {{Javadoc:SE|java/lang|Boolean}}, {{Javadoc:SE|java/lang|Byte}}, {{Javadoc:SE|java/lang|Character}}, {{Javadoc:SE|java/lang|Short}}, {{Javadoc:SE|java/lang|Integer}}, {{Javadoc:SE|java/lang|Long}}, {{Javadoc:SE|java/lang|Float}}, {{Javadoc:SE|java/lang|Double}}.

==== Дублирование ссылок и клонирование ====

Из-за того, что объектные переменные являются ссылочными, при присваивании не происходит копирования объекта. Так, если написать
<source lang="java">
Foo foo, bar;
…
bar = foo;
</source>,
то произойдет копирование адреса из переменной <code>foo</code> в переменную <code>bar</code>. То есть <code>foo</code> и <code>bar</code> будут указывать на одну и ту же область памяти, то есть на один и тот же объект; попытка изменить поля объекта, на который ссылается переменная <code>foo</code>, будет менять объект, с которым связана переменная <code>bar</code>, и наоборот. Если же необходимо получить именно ещё одну ''копию'' исходного объекта, пользуются или [[Метод (языки программирования)|методом]] (функцией-членом, в терминологии C++) <code>clone ()</code>, создающим копию объекта, или (реже) копирующим [[Конструктор (объектно-ориентированное программирование)|конструктором]] (конструкторы в Java не могут быть виртуальными, поэтому экземпляр класса-потомка будет неправильно скопирован конструктором класса-предка; метод клонирования вызывает нужный конструктор и тем самым позволяет обойти это ограничение).

Метод <code>clone()</code> требует, чтобы класс реализовывал [[Интерфейс (объектно-ориентированное программирование)|интерфейс]] <code>Cloneable</code> (об интерфейсах см. ниже). Если класс реализует интерфейс <code>Cloneable</code>, по умолчанию <code>clone()</code> копирует все поля (''мелкая копия''). Если требуется не копировать, а клонировать поля (а также их поля и так далее), надо переопределять метод <code>clone()</code>. Определение и использование метода <code>clone()</code> часто является нетривиальной задачей<ref>{{cite web
 | author        = 
 | authorlink    = 
 | datepublished = 
 | url           = http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#clone()
 | title         = Object (Java 2 Platform Standart Edition версии 1.4.2)
 | format        = 
 | work          = 
 | publisher     = [[Sun Microsystems]]
 | accessdate    = 2009-09-06
 | lang          = en
 | description   = Ссылка на документацию к методу Object.clone()
 | archiveurl    = http://www.webcitation.org/6170x2NN3
 | archivedate   = 2011-08-22
}}</ref>.

==== Инициализация переменных ====
Все переменные или требуют явного определения, или автоматически заполняются нулями (0, null, массивом нулей). Таким образом, изчезают гейзенбаги, связанные со случайным использованием неинициализированной памяти, характерные для низкоуровневых языков вроде C.

==== Сборка мусора ====

В языке Java невозможно явное удаление объекта из памяти — вместо этого реализована [[Сборка мусора (программирование)|Сборка мусора]]. Традиционным{{нет АИ|20|11|2009}} приёмом, дающим сборщику мусора «намёк» на освобождение памяти, является присваивание переменной пустого значения <code>null</code>. Это, однако, не значит, что объект, заменённый значением <code>null</code>, будет непременно и немедленно удалён, но есть гарантия, что этот объект будет удалён именно в будущем. Данный приём всего лишь устраняет ссылку на объект, то есть отвязывает указатель от объекта в памяти. При этом следует учитывать, что объект не будет удален сборщиком мусора, пока на него указывает хотя бы одна ссылка из используемых переменных или объектов. Существуют также методы для инициации принудительной сборки мусора, но не гарантируется, что они будут вызваны исполняющей средой, и их не рекомендуется использовать для обычной работы.

=== Классы и функции ===

Java не является процедурным языком: любая функция может существовать только внутри класса. Это подчёркивает терминология языка Java, где нет понятий «функция» или «функция-член» ({{lang-en|member function}}), а только ''метод''. В методы превратились и стандартные функции. Например, в Java нет функции <code>sin()</code>, а есть метод <code>Math.sin()</code> класса <code>Math</code> (содержащего, кроме <code>sin()</code>, методы <code>cos()</code>, <code>exp()</code>, <code>sqrt()</code>, <code>abs()</code> и многие другие). Конструкторы в Java не считаются методами. Деструкторов в Java не существует, а метод finalize() ни в коем случае нельзя считать аналогом деструктора.

=== Конструкторы ===
Конструктор — это специальный метод, который вызывается при создании нового объекта. Не всегда удобно инициализировать все переменные класса при создании его экземпляра. Иногда проще, чтобы какие-то значения были бы созданы по умолчанию при создании объекта. По сути, конструктор нужен для автоматической инициализации переменных.

Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

 <code>private int Cat(); // так выглядит метод по имени Cat
 Cat(); // так выглядит конструктор класса Cat
 </code>

В отличие от метода, конструктор никогда ничего не возвращает.

Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. Как правило, программисты стараются явно указать конструктор. Если явного конструктора нет, то Java автоматически создаст его для использования по умолчанию.

Создадим класс '''Box''' с конструктором, который просто установит начальные значения для коробки.

 <code>class Box {
     int width; // ширина коробки
     int height; // высота коробки
     int depth; // глубина коробки
 	
     // Конструктор
     Box(int a, int b) {
         width = a;
         height = b;
         depth = 10;
     }
 
     // вычисляем объём коробки
     int getVolume() {
     	return width * height * depth;
     }
 }
 </code>
Даже если конструктор специально НЕ определён, виртуальная машина Java обязательно его создаст (пустым).

...

==== Статические методы и поля ====

В Java (как и в C++) используются ''статические методы'' ({{lang-en|static method}} — в теории программирования их также называют методами класса), которые задаются при помощи ключевого слова <code>static</code>. Статические поля (переменные класса) имеют тот же смысл, что и в C++: каждое такое поле является собственностью класса, поэтому для доступа к статическим полям не требуется создавать экземпляры соответствующего класса.

Например, математические функции, реализованные в классе <code>Math</code>, представляют собой как раз статические методы данного класса. Поэтому можно писать
<source lang="java">double x = Math.sin(1);</source>
вместо
<source lang="java">Math m = new Math();
double x = m.sin(1);</source>

Поскольку статические методы существуют независимо от объектов (экземпляров класса), они не имеют доступа к обычным (нестатическим) полям и методам данного класса. В частности, при реализации статического метода недопустимо использовать идентификатор <code>this</code>.

Благодаря возможности статического импорта, возможно также вызывать статические функции и константы без указания класса, чтобы вместо такого кода
<source lang="java">
double x = Math.sin(Math.tan(Math.sqrt(y)) + Math.floor(24.5)) + Math.cos(42 * Math.PI);</source>
писать такой
<source lang="java">
import static java.lang.Math.*;
...
double x = sin(tan(sqrt(y)) + floor(24.5)) + cos(42 * PI);</source>


==== Завершённость (final) ====

Ключевое слово <code>final</code> (финальный) имеет разные значения при описании поля, метода или класса. 
# Финальное '''поле''' класса инициализируется при описании или в конструкторе класса (а статическое поле — в статическом блоке инициализации). Впоследствии его значение не может быть изменено. Если статическое поле класса или переменная проинициализированы константным выражением, они рассматриваются компилятором как [[константа (программирование)|именованная константа]]; в таком случае их значение может быть использовано в [[Switch (оператор)|операторах switch]] (для констант типа int), а также для условной компиляции (для констант типа boolean) при использовании с [[Условный оператор|оператором if]].
# Значения '''локальных переменных''', а также '''параметров метода''', помеченных ключевым словом final, не могут быть изменены после присвоения. При этом их значения могут использоваться внутри [[Внутренний класс#Анонимные (безымянные) классы|анонимных классов]]. 
# '''Метод''' класса, отмеченный словом final, не может быть переопределён при наследовании. 
# [[Листовой класс|Финальный '''класс''']] не может иметь наследников.
==== Абстрактность ====

В Java методы, не объявленные явно как <code>static</code>, <code>final</code> или <code>private</code>, являются [[Виртуальный метод|виртуальными]] в терминологии C++: при вызове метода, по-разному определённого в базовом и наследующем классах, всегда производится проверка времени выполнения.

[[Абстрактный метод|Абстрактным методом]] (модификатор <code>abstract</code>) в Java называется метод, для которого заданы параметры и тип возвращаемого значения, но не задано тело. Абстрактный метод определяется в классах-наследниках. Аналог абстрактного метода в C++ — чисто виртуальная функция (pure virtual function). Для того чтобы в классе можно было описывать абстрактные методы, сам класс тоже должен быть описан как абстрактный. Объекты абстрактного класса создавать нельзя.

==== Интерфейсы ====

Высшей степенью абстрактности в Java является интерфейс (<code>interface</code>). Все методы интерфейса абстрактны: описатель <code>abstract</code> даже не требуется. Интерфейс в Java не считается классом, хотя, по сути, является полностью абстрактным классом. Класс может наследовать/''расширять'' (<code>extends</code>) другой класс или ''реализовывать'' (<code>implements</code>) интерфейс. Кроме того, интерфейс может наследовать/расширять другой интерфейс.

В Java класс не может наследовать более одного класса, зато может реализовывать несколько интерфейсов. Множественное наследование интерфейсов не запрещено, то есть один интерфейс может наследоваться от нескольких.

Интерфейсы можно использовать в качестве типов параметров методов. Нельзя создавать экземпляры интерфейсов.

===== Маркерные интерфейсы =====
В Java есть интерфейсы, которые не содержат методов для реализации, а специальным образом обрабатываются JVM:

* <code>java.lang.Cloneable</code>
* <code>java.io.Serializable</code>
* <code>java.util.RandomAccess</code>
* <code>java.rmi.Remote</code>{{anchor|generics}}
==== Шаблоны в Java (generics) ====

Начиная с версии Java 5 в языке появился механизм [[обобщённое программирование|обобщённого программирования]] — шаблоны, внешне близкие к шаблонам C++. С помощью специального синтаксиса в описании классов и методов можно указать параметры-типы, которые внутри описания могут использоваться в качестве типов полей, параметров и возвращаемых значений методов.

<source lang="java">
// Объявление обобщённого класса
class GenericClass<E> {
  E getFirst() { ... }
  void add(E obj) { ... }
}

// Использование обобщённого класса в коде
GenericClass<String> var = new GenericClass<String>();
var.add("qwerty");
String p = var.getFirst();
</source>

Допускается обобщённое объявление классов, интерфейсов и методов. Кроме того, синтаксис поддерживает ограниченные объявления типов-параметров: указание в объявлении конструкции вида <code>&lt;T extends A & B & C...&gt;</code> требует, чтобы тип-параметр T реализовывал интерфейсы A, B, C и так далее, а конструкция <code>&lt;T super C&gt;</code> требует, чтобы тип-параметр T был типом C или одним из его предков.

В отличие от шаблонов C#, шаблоны Java не поддерживаются средой исполнения — компилятор просто создаёт байт-код, в котором никаких шаблонов уже нет. Реализация шаблонов в Java принципиально отличается от реализации аналогичных механизмов в C++: компилятор не порождает для каждого случая использования шаблона отдельный вариант класса или метода-шаблона, а просто создаёт одну реализацию байт-кода, содержащую необходимые проверки и преобразования типов. Это приводит к ряду ограничений использования шаблонов в программах на Java.

==== Проверка принадлежности к классу ====

В Java можно явно проверить, к какому классу принадлежит объект. Выражение <code>foo instanceof Foo</code> истинно, если объект <code>foo</code> принадлежит классу <code>Foo</code> или его наследнику, или реализует интерфейс <code>Foo</code> (или, в общем виде, наследует класс, который реализует интерфейс, который наследует <code>Foo</code>).

Далее функция <code>getClass()</code>, определённая для всех объектов, выдаёт объект типа <code>Class</code>. Для каждого класса создаётся не более одного описывающего его объекта типа <code>Class</code>, поэтому эти объекты можно сравнивать. Так, например, <code>foo.getClass() == bar.getClass()</code> будет истинно, если объекты <code>foo</code> и <code>bar</code> принадлежат к одному классу.

Кроме того, объект типа <code>Class</code> любого типа можно получить так: <code>Integer.class</code>, <code>Object.class</code>.

Прямое сравнение классов не всегда является оптимальным средством проверки на принадлежность к классу. Зачастую вместо него используют функцию <code>isAssignableFrom()</code>. Эта функция определена у объекта типа <code>Class</code> и принимает объект типа <code>Class</code> в качестве параметра. Таким образом, вызов <code>Foo.class.isAssignableFrom(Bar.class)</code> вернёт <code>true</code> в случае, если <code>Foo</code> является предком класса <code>Bar</code>. Так как все объекты являются потомками типа <code>Object</code>, вызов <code>Object.class.isAssignableFrom()</code> всегда вернёт <code>true</code>.

В паре с упомянутыми функциями объекта типа <code>Class</code> используются также функции <code>isInstance()</code> (эквивалентно <code>instanceof</code>), а также <code>cast()</code> (преобразует параметр в объект выбранного класса).

== Средства разработки ПО ==
* [[JDK]] — помимо набора библиотек для платформ [[Java SE]] и [[Java EE]], содержит компилятор командной строки javac и набор утилит, также работающих в режиме командной строки.
* [[NetBeans IDE]] — свободная интегрированная среда разработки для всех платформ Java — [[Java ME]], [[Java SE]] и [[Java EE]]. Пропагандируется [[Oracle]], владельцем технологии Java, как базовое средство для разработки ПО на языке Java и других языках ([[Си (язык программирования)|C]], [[C++]], [[PHP]], [[Fortran]] и др.).
* [[Eclipse (среда разработки)|Eclipse IDE]] — свободная интегрированная среда разработки для [[Java SE]], [[Java EE]] и [[Java ME]]<ref>{{cite web
 | url         = http://www.eclipse.org/pulsar/
 | title       = Pulsar - Eclipse Mobile Tools Platform
 | publisher   = Eclipse
 | accessdate  = 23 марта 2011
 | lang        = en
 | description = Проект eclipse для мобильных разработчиков
 | archiveurl  = http://www.webcitation.org/6170xVuSz
 | archivedate = 2011-08-22
}}</ref>. Пропагандируется [[IBM]], одним из важнейших разработчиков корпоративного ПО, как базовое средство для разработки ПО на языке Java и других языках ([[Си (язык программирования)|C]], [[C++]], [[Ruby]], [[Fortran]] и др.)
* [[IntelliJ IDEA]] — среда разработки для платформ [[Java SE]], [[Java EE]] и [[Java ME]]. Разработчик — компания [[JetBrains]]. Распространяется в двух версиях: свободной бесплатной (Community Edition) и коммерческой проприетарной (Ultimate Edition).
* [[JDeveloper]] — среда разработки для платформ [[Java SE]], [[Java EE]] и [[Java ME]]. Разработчик — компания [[Oracle]].
* [[BlueJ]] — среда разработки программного обеспечения на языке Java, созданная в основном для использования в обучении, но также подходящая для разработки небольших программ.
* [[Java для iOS]] — обучающее приложение и компилятор для [[iOS]].
* [[Geany]] — [[свободное программное обеспечение|свободная]] [[среда разработки программного обеспечения]], написанная с использованием [[Библиотека времени исполнения|библиотеки]] [[GTK2]]

== См. также ==
* [[Сравнение C Sharp и Java|Сравнение C# и Java]]
* [[Список Java API]]

== Примечания ==
{{примечания|2}}

== Литература ==
* {{книга
|заглавие = Java 8. Полное руководство, 9-е издание 
|оригинал = Java 8. The Complete Reference, 9th Edition 
|автор = Герберт Шилдт 
|страниц = 1376 
|isbn = 978-5-8459-1918-2 
|год = 2015 
|место =  М.
|издательство = [[Вильямс (издательство)|«Вильямс»]] 
}}
* {{книга
|заглавие = Java SE 8. Вводный курс 
|оригинал = Java SE 8 for the Really Impatient 
|автор = Кей С. Хорстманн 
|страниц = 208 
|isbn = 978-5-8459-1900-7 
|год = 2014 
|место =  М.
|издательство = [[Вильямс (издательство)|«Вильямс»]] 
}}
* {{книга
|заглавие = Руководство для программиста на Java: 75 рекомендаций по написанию надежных и защищённых программ 
|оригинал = Java Coding Guidelines: 75 Recommendations for Reliable and Secure Programs 
|автор = Фрэд Лонг, Дхрув Мохиндра, Роберт С. Сикорд, Дин Ф. Сазерленд, Дэвид Свобода 
|страниц = 256 
|isbn = 978-5-8459-1897-0 
|год = 2014 
|место =  М.
|издательство = [[Вильямс (издательство)|«Вильямс»]] 
}}
* {{книга
|заглавие = Java. Библиотека профессионала, том 1. Основы. 9-е издание 
|оригинал = Core Java, Volume I: Fundamentals (9th Edition) 
|автор = Кей С. Хорстманн, Гари Корнелл 
|страниц = 864 
|isbn = 978-5-8459-1869-7 
|год = 2013 
|место =  М.
|издательство = [[Вильямс (издательство)|«Вильямс»]] 
}}
* {{книга
|заглавие = Java 8 для чайников 
|оригинал = Java For Dummies, 6th edition 
|автор = Барри Берд 
|страниц = 400 
|isbn = 978-5-8459-1928-1 
|год = 2015 
|место =  М.
|издательство = [[Диалектика (издательство)|«Диалектика»]] 
}}
* {{книга
|заглавие = Язык программирования Java SE 8. Подробное описание, 5-е издание 
|оригинал = The Java Language Specification, Java SE 8 Edition (5th Edition) (Java Series) 
|автор = Джеймс Гослинг, Билл Джой, Гай Стил, Гилад Брача, Алекс Бакли 
|страниц = 672 
|isbn = 978-5-8459-1875-8 
|год = 2015 
|место =  М.
|издательство = [[Вильямс (издательство)|«Вильямс»]] 
}}
* {{книга
|автор = Джошуа Блох.
|заглавие = Java. Эффективное программирование
|оригинал = Effective Java
|место = М.
|издательство = [[Лори (издательство)|Лори]]
|год = 2002
|страниц = 224
|isbn = 5-85582-169-2
}}
* {{книга
|автор = Монахов Вадим.
|заглавие = Язык программирования Java и среда NetBeans
|ссылка = 
|издание = 3-е изд
|место = СПб.
|издательство = [[БХВ-Петербург]]
|год = 2011
|страниц = 704
|isbn = 978-5-9775-0671-7
}}
* {{книга
|автор = Брюс Эккель.
|заглавие = Философия Java
|оригинал = Thinking in Java
|издание = 3-е изд
|место = СПб.
|издательство = [[Питер (издательство)|Питер]]
|год = 2003
|страниц = 976
|isbn = 5-88782-105-1
}}

== Ссылки ==
{{викиучебник|Java}}
{{Викисловарь}}
* [http://java.com/ru/download/manual.jsp Автономный установщик последней версии Java]
* [http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html 7 версия Java]
* [http://www.oracle.com/technetwork/java/archive-139210.html Архив всех версий]
* [http://java.sun.com/ Официальный сайт]
* [http://mindview.net/Books/DownloadSites Bruce Eckel’s Free Electronic Books]{{ref-en}} — свободно распространяемые электронные версии книг Брюса Эккеля по C++ и Java вместе с исходным кодом
* W. Kahan, Joseph D. Darcy. [http://www.eecs.berkeley.edu/~wkahan/JAVAhurt.pdf How Java’s Floating-Point Hurts Everyone Everywhere]
* [http://docs.oracle.com/javase/6/docs/api/overview-summary.html Java™ Platform, Standard Edition 6 API Specification]

{{Java}}
{{Языки программирования}}

[[Категория:Java|*]]
[[Категория:Языки веб-программирования]]
[[Категория:Типобезопасные языки программирования]]
[[Категория:Языки программирования с автоматическим управлением памятью]]