[[Файл:Program memory layout.pdf|thumb|right|200px|alt=Альтернативный текст|Расположение [[стек]]а и [[Куча (память)|кучи]] в [[Адрес (информатика)|адресном пространстве]]]]'''Heap spraying''' в [[информационная безопасность|информационной безопасности]] — это [[Хакерская атака|атака]], использующая ошибки в работе с [[Виртуальная память|памятью]] приложения. Атакуя при помощи heap spraying, [[хакер]] заставляет приложение [[Динамическое распределение памяти|выделить память]] под большое количество объектов, содержащих [[Вредоносный код|вредоносный код]]. При этом повышается вероятность успеха [[эксплойт|эксплойта,]] который переносит [[Счётчик команд|поток исполнения]] на некоторую позицию внутри [[Куча (память)|кучи]]. Важно понимать, что без эксплойта, позволяющего изменять поток исполнения, heap spraying не нанесет какого-либо вреда. Атака основана на предсказуемости положения кучи в [[адресация памяти|адресном пространстве]] [[Процесс (информатика)|процесса]]. Помимо этого, выделение памяти в куче – это детерминированная операция, которая и позволяет с успехом применять эту технику. Heap spraying особенно эффективна в [[браузер]]ах, где хакер может выделять память, используя несколько строк [[JavaScript]] на [[Веб-страница|веб-странице]]. Важную роль играет сходство выделения памяти в различных [[операционная система|операционных системах]], что делает эту атаку кроссплатформенной. В результате можно внести определенную последовательность [[байт]] (например, машинную инструкцию) в заранее предсказанный адрес в [[компьютерная память|памяти]] целевого [[Процесс (информатика)|процесса]]<ref name="basics">{{статья |автор= Benjamin Livshits, Paruj Ratanaworabhan, Benjamin Zorn |заглавие= NOZZLE: A Defense Against Heap-spraying Code Injection Attacks. |ссылка=http://research.microsoft.com/pubs/81085/usenixsec09b.pdf |язык= eng |тип=	Inproceedings |год= 2009 |страницы= 38}}</ref>.

При [[Процесс (информатика)#Создание процесса|создании процесса]] в [[операционная система|операционной системе]] под его нужды выделяется [[адресация памяти|адресное пространство]]<ref name="Tanenbaum">{{книга |автор= Таненбаум Э., Вудхалл А.|заглавие= Операционные системы. Разработка и реализация |место=СПб. |издательство= Питер |год= 2007|страниц= 704|страницы= 78-252}}</ref><ref name="Rixter">{{книга |автор= Рихтер Дж.|заглавие=Windows для профессионалов: создание эффективных Win32 приложений с учетом специфики 64х разрядной версии Windows|место= М. |издательство= Русская Редакция |год= 2008|страниц= 720|страницы= 68-118,333-418}}</ref><ref name="Stiv">{{книга |автор= У. Ричард Стивенс, Стивен А. Раго |заглавие= UNIX. Профессиональное программирование|место= СПб. |издательство= Символ-Плюс |год= 2014|страниц= 1104|страницы=288-351}}</ref>, в котором расположены пользовательские данные, [[Машинный код|исполняемый код]] и некоторая системная информация, которая зависит от конкретной операционной системы. Пользовательские данные распределяются между кучей и стеком в зависимости от способа [[Динамическое распределение памяти|выделения памяти]] под них<ref name="origin">{{книга |автор= Брайан Керниган, Деннис Ритчи|заглавие= Язык программирования Си  |издательство= Вильямс |год= 2015|страниц= 	304|страницы= 93-123}}</ref>. Так, в сегменте [[стек]]а хранятся переменные с автоматическим классом размещения, а также информация, которая сохраняется при каждом вызове функции, например, статические переменные и адрес возврата при [[си (язык программирования)#Вызов функции|вызове функции]]. [[Куча (память)|Куча]] — это область [[Динамическое распределение памяти|динамической памяти]], то есть при [[Динамическое распределение памяти|динамическом выделении памяти]] место выделяется в куче. Традиционно куча и стек растут навстречу друг другу<ref name="Tanenbaum" /><ref name="Rixter" /><ref name="Stiv" />.

== Основная концепция ==
[[Файл:Memory_during_spraying.jpg|left|thumb|407x407px|Память "До" и "После"  heap spraying]]
Heap spraying сама по себе не является [[Уязвимость (компьютерная_безопасность)|уязвимостью]]. Однако она может быть использована для доставки [[Вредоносный код|вредоносного кода]] в [[Переполнение буфера#Эксплуатация|исполняемую область]] [[Виртуальная память|памяти процесса]]. Эта техника использует детерминированность операции [[Динамическое распределение памяти|выделения памяти]] в [[операционная система|системе]]. Имеется в виду, что большой объём памяти часто располагается с одним и тем же [[Адрес (информатика)#Вычисляемые адреса|смещением]] в [[Адрес (информатика)|адресном пространстве]] процесса. Однако эта техника не в состоянии создать брешь в самой системе безопасности. Поэтому для её использования необходима уязвимость, позволяющая изменить [[Счётчик команд|порядок исполнения команд]] (машинных инструкций)<ref name="basics2">{{статья |автор= 	Thomas Toth, 	Christopher Kruegel	 |заглавие= Accurate buffer overflow detection via abstract payload execution |ссылка=http://dl.acm.org/citation.cfm?id=1754723|язык= eng|издание=RAID'02 Proceedings of the 5th international conference on Recent advances in intrusion detection |тип= Proceeding |год= 2002| месяц = 10|день =16 |страницы= 274-291|isbn=3-540-00020-8 }}</ref>.

Использовать эту технику трудно, поскольку очень велико число факторов, влияющих на исполнение процесса (с точки зрения хакера). Тем не менее, с помощью heap spraying можно выполнить большое число инструкций, что частично компенсирует эту трудность и позволяет повысить вероятность успешного взлома<ref name="ASLR">{{статья |автор= Tilo Muller |заглавие= ASLR Smack & Laugh Reference |ссылка=https://ece.uwaterloo.ca/~vganesh/TEACHING/S2014/ECE458/aslr.pdf |язык= eng |год= 2008|месяц=12|день=17|страницы= 21}}</ref>.

Heap spraying может быть реализована для большинства [[операционная система|операционных систем]] и [[Микроархитектура|архитектур]]. Основная трудность – нахождение [[Уязвимость (компьютерная_безопасность)|уязвимости]], позволяющей перенаправить [[Счётчик команд|поток исполнения]].  [[Динамическое распределение памяти|Динамическое выделение]] большого количества памяти, как говорилось ранее, — операция, позволяющая предсказать [[Виртуальная память#Страничная организация виртуальной памяти|положение кучи в памяти]] (в момент [[Страничная память|проецирования виртуальной памяти на физическую]])<ref name=":0" /> . Каждый раз выполняя одну и ту же последовательность обращений к памяти, куча будет с большой долей вероятности оказываться на одном и том же месте<ref name="ASLR"></ref><ref name= "basics2"/>.[[Файл:Array_for_spraying.jpg|400x400px|thumb|Характерный вид блоков]]Однако, чтобы повысить эту вероятность, необходимо чтобы размер [[Менеджер памяти|куска выделяемой памяти]] был сопоставим с размером [[Сегментная адресация памяти|сегмента]] или [[Страничная память|страницы]], в зависимости от [[Виртуальная память|способа организации памяти]]<ref name="ASLR" />.
Основная проблема этой атаки – изменение [[Счётчик команд|потока исполнения]]. Без возможности перехвата выполнения данный вид атаки не имеет смысла. Некоторые функции могут хранить [[Стек вызовов|адрес возврата]] в куче, тогда хакер может попытаться изменить их. В этом случае при возврате из такой функции произойдет перемещение в участок [[Виртуальная память|памяти]], удобный для [[хакер]]а, и, как следствие, начнет исполняться  [[Вредоносный код|вредоносный код]]. Любая функция, считывающая [[Адрес (информатика)|адрес]], находящийся в куче, может быть использована как уязвимость. Хакер может подменить этот адрес на адрес модифицированного им участка памяти. Это может привести к перенаправлению потока исполнения на вредоносный код. Однако это не так просто, как кажется<ref name="basics" /><ref name=":0">{{книга |автор= 	Марк Руссинович, Дэвид Соломон|заглавие=Внутреннее устройство Windows|место= СПб. |издательство= Питер |год= 2013|страниц= 800|страницы= 104-681}}</ref>.  

Корректность [[Адрес (информатика)|адреса]] (его размер, смещение относительно начала страницы), используемого для подмены, сильно зависит от архитектуры. Потому на практике используют блоки, состоящие в основном из [[NOP]]<nowiki/>ов, дописывая в конце необходимый код. Этот прием позволяет не задумываться о точности высчитывания адреса и направить поток исполнения в приблизительное место в [[Адрес (информатика)|адресном пространстве]]<ref name="basics" />. 

Шаги, направленные на реализацию heap spraying:
* Определение размера куска [[Динамическое распределение памяти|выделяемой памяти]] таким образом, чтобы одно выделение соответствовало размеру страницы.
* Выделение нескольких кусков, в которых располагаются [[NOP]] и [[Шелл-код|shell-код]].
* Использование известной уязвимости для перенаправления [[Счётчик команд|счетчика команд]] на предполагаемое положение кусков, например, при помощи [[Переполнение стека|переполнения стека]].
* Исполнение выделенной области<ref name="basics"></ref><ref name="basics2"/>.
Этот тип атак очень эффективен в [[браузер|браузерах]].  Большинство браузеров поддерживают исполнение [[Сценарный язык|скриптов]]. Хакер может  [[Динамическое распределение памяти|выделить необходимую память]], используя несколько строк  [[JavaScript]] или [[ActionScript]] на веб-странице. Важную роль играет схожесть выделения памяти в различных [[операционная система|операционных системах]], что делает эту атаку кроссплатформенной. Более того, адреса на которые необходимо совершить переход, будут похожи<ref name="Black Hat">{{статья |автор= Sotirov A. |заглавие=  Heap feng shui in javascript |ссылка=https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf |язык= eng |год= 2007|страницы= 55}}</ref>.

== История ==
Первый раз heap spraying использовалась в 2001 году и стала широко распространенной летом 2005 года. После было найдено большое количество [[Уязвимость (компьютерная безопасность)|уязвимостей]] в [[Internet Explorer]]<ref>{{статья |автор= HwaiGeeng, Chew |заглавие= Security Holes in ISAPI Extensions |ссылка=https://www.sans.org/reading-room/whitepapers/win2k/security-holes-isapi-extensions-209 |язык= eng |тип=	Inproceedings |год= 2001 |страницы= 12}}</ref><ref>{{статья |автор= Black Hat|заглавие= Security Holes in ISAPI Extensions |ссылка=https://media.blackhat.com/bh-us-10/whitepapers/Meer/BlackHat-USA-2010-Meer-History-of-Memory-Corruption-Attacks-wp.pdf |язык= eng |тип=	Inproceedings |год= 2010 |страницы= 35}}</ref>. Эксплойты были очень похожи между собой. Каждый такой эксплойт состоял из heap spraying, метод реализации которой не изменялся, и переноса счетчика команд на необходимое место в [[Виртуальная память|памяти]]. Потому новый [[эксплойт]] получался изменением нескольких строк [[HTML]] и переключением на новую уязвимость<ref name="basics"></ref>.

== Реализация ==

=== JavaScript ===
Самый простой способ выделить место в [[Виртуальная память|памяти]] [[браузер]]а — декларировать строчную переменную и инициализировать её<ref name="basics"></ref>.

Примеры выделения памяти на [[JavaScript]]<ref name="Black Hat" />:
<source lang="javascript"> 
		var myvar = "CORELAN!";
		var myvar2 = new String("CORELAN!");
		var myvar3 = myvar + myvar2;
		var myvar4 = myvar3.substring(0,8);
</source>
Это очень простые примеры, так как выделенные строки небольшие. Кусок [[Шелл-код|shell-кода]] значительно больше, но все же меньше [[Страничная память|целой страницы памяти]].


Гипотетически можно записать необходимый [[Шелл-код|shell-код]] много раз в каждый выделяемый нами блок, но тогда злоумышленнику придется следить, на какой конкретно [[Адрес (информатика)|адрес]] попадает указатель, так как он не должен попасть на середину  [[Машинный код|исполняемого кода]]. Обычно поступают по-другому — выделяют куски, содержащие множество [[NOP]]<nowiki/>ов, и в конце прописывают необходимые команды. Тогда в силу линейности расположения блоков в куче проще соблюсти [[Счётчик команд|линейность исполнения кода]] и не нужно заботиться о точности попадания на начало куска памяти<ref name="Black Hat"></ref>.

При правильном выборе размера [[Динамическое распределение памяти|выделяемые куски]] памяти должны быть очень близки к размеру элемента кучи. Если выделяемый кусок памяти будет меньше, то оставшееся место будет свободно. [[Менеджер памяти]], в лучшем случае, оставит системный мусор в этом «незанятом пространстве», а в худшем положит объект, подходящий по размеру. В любом случае это приведет к ошибке при попытке исполнить данный участок памяти<ref name="Black Hat"></ref><ref name = "basics"/>.


Таким образом, используемый злоумышленниками скрипт выглядит так<ref name="Black Hat"></ref>:
<source lang="html">
		<html>
		<script >
		var shellcode = unescape('%u\4141%u\4141'); // это надпись CORELAN
		var bigblock = unescape('%u\9090%u\9090'); //90- это код NOP
		var headersize = 20;
		var slackspace = headersize + shellcode.length;// начальный размер нашего куска: полезный код + размер заголовка
		while (bigblock.length < slackspace) bigblock += bigblock; //заполнение NOP-ами 
		var fillblock = bigblock.substring(0,slackspace);//полезный код- наполнение
		var block = bigblock.substring(0,bigblock.length - slackspace);//просто NOPы
		while (block.length + slackspace < 0x40000) block = block + block + fillblock;
        //заполнение до размера элемента кучи- в данном случае- это 0x40000
		var memory = new Array();
		for (i = 0; i < 500; i++){ memory[i] = block + shellcode }// выделение нескольких таких элементов.
		</script>
		</html>
</source>
<code>unescape()</code>- это функция, позволяющая положить байты именно в том порядке, в котором указано в аргументе<ref name="basics"></ref>.

=== VBscript ===
[[Visual Basic Scripting Edition|VBscript]] используют в [[Internet Explorer]] для создания строк с помощью <code>string</code>. Концептуально не отличается от реализации на [[Heap spraying#JavaScript|JavaScript]], только названия функций изменяются<ref name="basics2"/>.

=== ActionScript ===
В июле 2009 были найдены [[эксплойт]]ы, позволяющие использовать [[ActionScript]] для реализации heap spraying в [[Adobe Flash]]<ref name="basics"></ref>.

=== HTML5 ===
В сентябре 2012 на EuSecWest 2012<ref>{{статья |автор = Anibal Sacco, Federico Muttis|заглавие = HTML5 Heap Sprays, Pwn All The Things|ссылка = http://www.coresecurity.com/corelabs-research/publications/html5-heap-sprays-pwn-all-things|язык = eng|год = 2012}}</ref> была представлена новая реализация. Федерико Мутиис (Federico Muttis) и Анибал Сакко (Anibal Sacco) показали, что heap spraying с высокой степенью гранулярности может быть реализован при помощи технологий [[HTML5]]. Они использовали низкоуровневый растровый интерфейс, предоставляемый [[Canvas (HTML)#API|canvas API]].

=== Изображения ===
Существуют методы, использующие загрузку изображений. Изображение составляют из [[NOP]]<nowiki/>ов и далее действуют, как и в предыдущих случаях<ref name="basics"/><ref name = "Black Hat"/>.

== Способы предотвращения ==
Как и при любых [[Переполнение буфера|переполнениях буфера]], есть три основных пути защиты.<ref name="basics"></ref> Часто проще предотвратить изменение [[Счётчик команд|потока исполнения]], чем само использование буфера. Современные [[операционная система|операционные системы]] используют все перечисленные ниже методы:
# Предотвращение исполнения путем разделения данных и [[Машинный код|исполняемого кода]], обычно с использованием архитектурных решений, например [[NX bit]]. Например, уже в большинстве ОС внедрен [[Предотвращение выполнения данных|DEP]]<ref name="basics" />
# Повышение случайности расположения данных в [[Виртуальная память|памяти]]. Например, чтобы следующий выделенный элемент кучи не имел фиксированного [[Адресация памяти#Вычисление адресов|смещения]] относительно текущего. Уже внедрено в большинстве ОС: [[Address Space Layout Randomization|ASLR]]<ref name= "ASLR"/>.
# Увеличение количества проверок соблюдения границ буфера в [[Менеджер памяти|менеджере памяти]].
Проекты, связанные с данным типом атаки:
* проект Nozzle от Microsoft Research ставит своей целью предотвращения heap spraying<ref name = "basics"/>.
* BuBBle — это другой проект, целью которого является минимизация урона от данной атаки<ref name="buble">{{статья |автор= Francesco Gadaleta, Yves Younan, Wouter Joosen |заглавие= BuBBle: A Javascript Engine Level Countermeasure against Heap-Spraying Attacks |ссылка= https://lirias.kuleuven.be/bitstream/123456789/265421/1/fulltext.pdf |язык= eng |год= 2010 |страницы= 17}}</ref>.

== См. также ==
* [[Переполнение буфера]]
* [[Переполнение стека]]
* [[Стек вызовов]]
* [[Куча (память)]]
* [[Хакерская атака]]
* [[Предотвращение выполнения данных|Data Execution Prevention]]

== Примечания ==

{{примечания}}

== Литература ==
* {{книга |автор= Рихтер Дж.|заглавие=Windows для профессионалов: создание эффективных Win32 приложений с учетом специфики 64х разрядной версии Windows|место= М. |издательство= Русская Редакция |год= 2008|страниц= 720|страницы= 68-118,333-418}}
* {{книга |автор= У. Ричард Стивенс, Стивен А. Раго |заглавие= UNIX. Профессиональное программирование|место= СПб. |издательство= Символ-Плюс |год= 2014|страниц= 1104|страницы=288-351}}
* {{книга |автор= Таненбаум Э., Вудхалл А.|заглавие= Операционные системы. Разработка и реализация |место=СПб. |издательство= Питер |год= 2007|страниц= 704|страницы= 78-252}}
* {{книга |автор= Брайан Керниган, Деннис Ритчи|заглавие= Язык программирования Си  |издательство= Вильямс |год= 2015|страниц= 	304|страницы= 93-123}}
* {{книга |автор= 	Марк Руссинович, Дэвид Соломон|заглавие=Внутреннее устройство Windows|место= СПб. |издательство= Питер |год= 2013|страниц= 800|страницы= 104-681}}

== Ссылки ==
* {{cite web |url= https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/|title= Exploit Writing Tutorial |publisher= Corelan Team|accessdate=2015-12-12 |lang=eng}}
* {{cite web |url= https://msdn.microsoft.com/ru-ru/library/ee787088(v=vs.110).aspx|title= Fundamentals of Garbage Collection
 |publisher= MSDN|accessdate=2015-12-12 |lang=eng}}
* {{cite web |url= https://www.opennet.ru/docs/RUS/ipcbook/node8.html |title= Запуск процессов с помощью вызова exec()|publisher= OpenNET |accessdate=2015-12-12 |lang=rus}}
* {{cite web |url= https://wiki.debian.org/Hugepages|title= Hungpages|publisher= Debian |accessdate=2015-12-12 |lang= eng}}
* {{cite web |url= https://www.fireeye.com/blog/threat-research/2009/07/actionscript_heap_spray.html |title= ActionScript Heap Spray|publisher= Julia Wolf  |accessdate=2015-12-12 |lang= eng}}
* {{cite web |url= https://exploiting.wordpress.com/2012/10/03/html5-heap-spray-eusecwest-2012/|title= HTML5 Heap spray |publisher= EUSecWest 2012 |accessdate=2015-12-12 |lang= eng}}
* {{cite web |url= https://developer.cisco.com/media/onepk_security_guide/GUID-527CB4BF-B5AC-41A3-92B1-883C09B8730D.html|title= Address Space Layout Randomization (ASLR)|publisher= CISCO |accessdate=2015-12-12 |lang= eng}}

{{изолированная статья}}

[[Категория:Атаки и эксплойты]]
{{Добротная статья|Теория информации и криптография}}
{{рецензия}}