{{Значения|Алгоритм Форда}}
'''Алгоритм Беллмана–Форда'''&nbsp;— алгоритм поиска кратчайшего [[Путь (теория графов)|пути]] во [[Взвешенный граф|взвешенном графе]]. За время ''O(|V| × |E|)'' алгоритм находит кратчайшие пути от одной [[Вершина (граф)|вершины]] графа до всех остальных. В отличие от [[Алгоритм Дейкстры|алгоритма Дейкстры]], алгоритм Беллмана–Форда допускает [[ребро (теория графов)|рёбра]] с отрицательным [[вес (теория графов)|весом]]. Предложен независимо [[Беллман, Ричард|Ричардом Беллманом]] и [[Форд, Лестер|Лестером Фордом]].

== История ==
Алгоритм маршрутизации [[RIP2|RIP]] (алгоритм Беллмана–Форда) был впервые разработан в 1969 году, как основной для сети [[ARPANET]].

== Формулировка задачи ==
Дан ориентированный или неориентированный [[Граф (математика)|граф]] ''G'' со взвешенными рёбрами. Длиной пути назовём сумму весов рёбер, входящих в этот путь. Требуется найти кратчайшие пути от выделенной вершины ''s'' до всех вершин графа.

Заметим, что кратчайших путей может не существовать. Так, в графе, содержащем цикл с отрицательным суммарным весом, существует сколь угодно короткий путь от одной вершины этого цикла до другой (каждый обход цикла уменьшает длину пути). Цикл, сумма весов рёбер которого отрицательна, называется ''отрицательным циклом''.

== Решение задачи на графе без отрицательных циклов ==
Решим поставленную задачу на графе, в котором заведомо нет отрицательных циклов.

Для нахождения кратчайших путей от одной вершины до всех остальных, воспользуемся методом [[Динамическое программирование|динамического программирования]]. Построим [[Матрица (математика)|матрицу]] A<sub>ij</sub>, элементы которой будут обозначать следующее:
A<sub>ij</sub>&nbsp;— это <b>длина кратчайшего пути из ''s'' в ''i''</b>, содержащего не более ''j'' рёбер.

Путь, содержащий 0 рёбер, существует только до вершины ''s''. Таким образом, A<sub>i0</sub> равно 0 при ''i''&nbsp;=&nbsp;''s'', и +∞ в противном случае.

Теперь рассмотрим все пути из ''s'' в ''i'', содержащие ровно ''j'' рёбер. Каждый такой путь есть путь из <math>j-1</math> ребра, к которому добавлено последнее ребро. Если про пути длины <math>j-1</math> все данные уже подсчитаны, то определить ''j''-й столбец матрицы не составляет труда.

Так выглядит алгоритм поиска длин кратчайших путей в графе без отрицательных циклов:

 '''for''' <math>v \in V</math>
   '''do''' <math>d[v] \gets +\infty</math>
 <math>d[s] \gets 0</math>
 '''for''' <math>i \gets 1</math> '''to''' <math>|V| - 1</math>
   '''do for''' <math>(u, v) \in E</math>
     '''if''' <math>d[v] > d[u] + w(u, v)</math>
       '''then''' <math>d[v] \gets d[u] + w(u, v)</math>
 '''return''' <math>d</math>

Здесь ''V''&nbsp;— множество вершин графа ''G'', ''E''&nbsp;— множество его рёбер, а ''w''&nbsp;— весовая функция, заданная на ребрах графа (возвращает длину дуги ведущей из вершины ''v'' в ''u''), d - массив, содержащий расстояния от вершины s до любой другой вершины.

Внешний цикл выполняется <math>|V| - 1</math> раз, поскольку кратчайший путь не может содержать большее число ребер, иначе он будет содержать цикл, который точно можно выкинуть.

Вместо массива ''d'' можно хранить всю матрицу A, но это требует ''O(V²)'' памяти. Зато при этом можно вычислить и сами кратчайшие пути, а не только их длины. Для этого заведем матрицу ''P<sub>ij</sub>''.

Если элемент ''A<sub>ij</sub>'' содержит длину кратчайшего пути из ''s'' в ''i'', содержащего ''j'' рёбер, то ''P<sub>ij</sub>'' содержит предыдущую вершину до ''i'' в одном из таких кратчайших путей (ведь их может быть несколько).

Теперь алгоритм Беллмана–Форда выглядит так:

 '''for''' <math>v \in V</math>
   '''for''' <math>i \gets 0</math> '''to''' <math>|V| - 1</math>
     '''do''' <math>A_{vi} \gets +\infty</math>
 <math>A_{s0} \gets 0</math>
 '''for''' <math>i \gets 1</math> '''to''' <math>|V| - 1</math>
   '''do for''' <math>(u, v) \in E</math>
     '''if''' <math>A_{vi} > A_{u, i-1} + w(u, v)</math>
       '''then''' <math>A_{vi} \gets A_{u, i-1} + w(u, v)</math>
            <math>P_{vi} \gets u</math>

После выполнения этого алгоритма элементы <math>A_{i, j}</math> содержат длины кратчайших путей от ''s'' до ''i'' с количеством ребер ''j'', и из всех таких путей следует выбрать самый короткий. А сам кратчайший путь до вершины ''i'' с ''j'' ребрами восстанавливается так:

 '''while''' <math>j > 0</math>
   <math>p[j] \gets i</math>
   <math>i \gets P_{ij}</math>
   <math>j \gets j - 1</math>
 '''return''' ''p''

== Граф с отрицательными циклами ==
Алгоритм Беллмана–Форда позволяет очень просто определить, существует ли в графе ''G'' отрицательный цикл, достижимый из вершины ''s''. Достаточно произвести внешнюю итерацию цикла не <math>|V| - 1</math>, a ровно |''V''| раз. Если при исполнении последней итерации длина кратчайшего пути до какой-либо вершины строго уменьшилась, то в графе есть отрицательный цикл, достижимый из ''s''.
На основе этого можно предложить следующую оптимизацию: отслеживать изменения в графе и, как только они закончатся, сделать выход из цикла (дальнейшие итерации будут бессмысленны).

== Литература ==
* R. Bellman: On a Routing Problem // Quarterly of Applied Mathematics. 1958. Vol 16, No. 1. C. 87-90, 1958.
* L. R. Ford, Jr., D. R. Fulkerson. Flows in Networks, Princeton University Press, 1962.

== См. также ==
* [[Исследование операций]]

== Ссылки ==
* [http://e-maxx.ru/algo/ford_bellman Реализация алгоритма Форда–Беллмана на e-maxx.ru]
* [http://e-maxx.ru/algo/negative_cycle Реализация алгоритма Поиска отрицательного цикла на e-maxx.ru]
* [http://books.google.ru/books?id=NLngYyWFl_YC&lpg=PA639&ots=BxRrCy6fB5&dq=bellman%20ford%20algorithm%20cormen&hl=ru&pg=PA589#v=onepage&q=bellman%20ford%20algorithm%20cormen&f=false Псевдокод из книги "Introduction To Algorithms" (Thomas H Cormen,Charles E Leiserson,Ronald L Rivest,Clifford Stein)]


{{Алгоритмы поиска на графах 2}}

{{math-stub}}
{{rq|topic=math|style|wikify|img}}

[[Категория:Алгоритмы поиска на графах]]